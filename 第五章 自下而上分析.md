
---

### 第一讲：自下而上分析的核心思想 —— “搭积木”

#### 1.1 核心动作：移入-规约 (Shift-Reduce)

自下而上分析器的工作过程，可以用一个非常简单的循环来描述，这个循环只包含两种基本动作：

1.  **移入 (Shift)**：
    *   **动作**：将输入队列的**第一个** Token，移动到**分析栈**的顶部。
    *   **比喻**：从零件盒里，拿一个最基本的乐高积木，放到你的工作台上。

2.  **规约 (Reduce)**：
    *   **动作**：当分析栈顶部的**一串符号**，正好匹配了某个产生式规则的**右部**时，就将这串符号从栈中**弹出**，然后将该规则的**左部非终结符**压入栈中。
    *   **比喻**：你发现工作台上的几块积木（比如：轮胎、轮毂、车轴），正好可以拼成一个“车轮”部件。于是你把这些零散积木拿走，换上一个已经组装好的“车轮”部件。你完成了一次**抽象**。

**整个分析过程**，就是在这两种动作之间不断抉择，直到最终栈里只剩下开始符号 `S`，并且输入也被耗尽，此时分析成功。

---
#### 1.2 核心概念：规约 (Reduction)

**规约，就是推导的“逆过程”。**

*   **推导 (Derivation)**：`E ⇒ E + T` (把 `E` 展开成 `E+T`)
*   **规约 (Reduction)**：`E + T ⇒ E` (把 `E+T` 归结为 `E`)

**自下而上分析，本质上就是一个不断寻找“可规约子串”并进行规约的过程。**

**例子**:
*   **文法**: `S → aABe`, `A → Abc | b`, `B → d`
*   **输入**: `abcbde`
*   **一个可能的规约序列**:
    `abcbde`
    `aAbcde`  (将 `b` 规约为 `A`)
    `aAde`    (将 `Abc` 规约为 `A`)
    `aABe`    (将 `d` 规约为 `B`)
    `S`       (将 `aABe` 规约为 `S`) -> **分析成功！**

**但是，新的问题来了：在每一步，我们怎么知道应该规约哪一部分呢？**
*   在 `abcbde` 中，第一个 `b` 是一个合法的可规约项。
*   在 `aAbcde` 中，`Abc` 是一个合法的可规约项。

这个“在当前这一步，最应该被规约的子串”，有一个专门的名字，叫做**句柄 (Handle)**。

**什么是句柄？**
> **句柄是<u>最右推导</u>的逆过程。** 在一个句型中，句柄是与某个产生式右部匹配的子串，将它规约为该产生式的左部非终结符，可以得到上一步的最右句型。

**简单理解**：句柄就是“**正确的、不会导致我们走入死胡同的**”那个可规约子串。自下而上分析的**全部挑战**，就在于如何**准确地找到句柄**。

---
#### 1.3 终极目标：规范规约 (Canonical Reduction)

一个最完美的自下而上分析过程，就是**规范规约**。它指的是，分析的每一步都是**最右推导的精确逆过程**。

*   **最右推导**: 
<img width="1419" height="886" alt="image" src="https://github.com/user-attachments/assets/7872237d-b4dc-4d08-8474-8462a9dfdf71" />

*   **规范规约**:
  <img width="1413" height="807" alt="image" src="https://github.com/user-attachments/assets/c819d679-970a-4882-91f8-fb277fecad80" />

将待规约句型从左向右入栈，对应其最右推导语法树的最左叶子到最右叶子，一旦发现栈顶有可规约项就是也就是最左的2层子树也就是句柄就规约，也就是将该语法树的这个子树的叶子归约到子树根节点
**寻找句柄的挑战**:
*   我们怎么知道 `abcbde` 的句柄是第一个 `b`，而不是第二个 `b`？
*   我们怎么知道 `aAbcde` 的句柄是 `Abc`，而不是 `b`？

不同的分析方法，提供了不同的寻找句柄的策略：
*   **算符优先分析法**：通过比较运算符之间的优先级来“框定”句柄的边界。
*   **LR 分析法**：通过一个强大的 DFA（状态机）来精确地识别句柄的出现，并决定何时进行规约。这是最通用、最准确的方法。

---
#### 1.4 工作台：符号栈

为了实现“移入-规约”这个过程，并有效地追踪我们已经“拼好”的部件，我们需要一个**符号栈**。

**工作流程**:
1.  **初始状态**: 栈为空，输入指针指向第一个 Token。
2.  **循环**:
    a.  **决策**: 分析器根据当前**栈顶的状态**和**下一个输入 Token**，来决定是“移入”还是“规约”。（决策的依据，就是不同分析方法的核心，比如 LR 分析表）。
    b.  **执行“移入”**: 从输入队列拿一个 Token，压入栈顶。
    c.  **执行“规约”**:
        i.  在栈顶找到句柄（比如 `αβ`）。
        ii. 把它从栈顶弹出。
        iii. 把对应的产生式左部非终结符 `A` 压入栈顶。
3.  **结束**:
    *   **成功**: 当栈里只剩下开始符号 `S`，且输入队列为空时，分析成功。
    *   **失败**: 如果在某个决策点，分析器发现既不能移入，也不能规约，则报告语法错误。

---
### 补充一：短语、直接短语与句柄 (与语法树的关系)

这些概念都是**基于语法树**来定义的，它们描述了语法树中不同“片段”的层次关系。

**我们先来看一棵语法树：**

*   **文法**: `E → E * T | T`, `T → T + F | F`, `F → id`
*   **句子**: `id * id + id`
*   **它的一个最右推导**: `E ⇒ E*T ⇒ E*T+F ⇒ E*T+id ⇒ E*F+id ⇒ E*id+id ⇒ T*id+id ⇒ F*id+id ⇒ id*id+id`

**对应的语法树：**
```
      E
      |
      E -- * -- T
      |       |
      T       T -- + -- F
      |       |       |
      F       F      id
      |       |
      id      id
```

**现在，我们来定义这些概念：**

#### 1. 短语 (Phrase)

*   **定义**: 语法树中的**任一棵子树**，其**所有末端节点 (叶子)** 从左到右连接起来形成的字符串，就是相对于该子树根节点的一个**短语**。
*   **直观理解**: 短语就是句子中一个**语法上可以被看作一个整体**的部分。
*   **例子 (看上面的树)**:
    *   以最顶层的 `E` 为根的子树，它的叶子是 `id * id + id`。所以 `id * id + id` 是 `E` 的一个短语。
    *   以中间的 `T` 为根的子树，它的叶子是 `id + id`。所以 `id + id` 是 `T` 的一个短语。
    *   以最左边的 `F` 为根的子树，它的叶子是 `id`。所以第一个 `id` 是 `F` 的一个短语。

#### 2. 简单短语 (Simple Phrase)

*   **定义**: 如果一棵子树的**高度只有2** (即根节点直接连接所有叶子节点)，那么这棵子树的叶子形成的短语，就叫做**简单短语**。
*   **直观理解**: 简单短语是一个**一步推导**就能得到的短语。它正好对应某个产生式的**右部**。
*   **例子**:
    *   `E → T` 这棵子树（最左边的 `E` 和 `T`），它的叶子是 `T` 的叶子，即 `id`。但它的高度不是2。
    *   `T → F` 这棵子树（最左边的 `T` 和 `F`），叶子是`id`。也不是。
    *   `F → id` 这棵子树，高度是2！所以，`id` 是一个简单短语。
    *   `T → T + F` 这棵子树，它的叶子是 `id + id`。但它的高度超过2了，所以 `id+id` 不是简单短语。

#### 3. 句柄 (Handle)

*   **PPT 的定义**: “**最左简单短语**”。
*   **定义**: 一个句型的**句柄**，是这个句型所对应的语法树中，**最左边的那棵高度为2的子树**的叶子节点串。
*   **直观理解**: 句柄就是当前这一步，**最应该被规约**的那个部分。它对应了**最右推导的逆过程**。
*   **为什么是最左？** 因为我们是从左到右扫描输入的，我们最先遇到的那个可以被一步规约的完整单元，就是我们当前能处理的句柄。
*   **例子**:
    *   对于句型 `id * id + id`，它的语法树中，最左边的、高度为2的子树是 `F → id`。所以，**第一个 `id` 就是句柄**。
    *   规约后，句型变成 `F * id + id`。
    *   对于 `F * id + id`，最左的简单短语是 `F` 本身（来自`T->F`）。规约后得到 `T * id + id`。
    *   ... 这个过程不断进行，每一次都规约“最左简单短语”，就是在模拟最右推导的逆过程。

**总结**：`短语 > 简单短语 > 句柄`。句柄是简单短语中最特殊、最靠左的一个，它是自下而上分析器每一轮的“操作目标”。

---
### 第二讲：算符优先分析 —— 一个简单的“热身”



#### **引言：我们的目标与视角**
在自下而上分析的世界里，我们的核心任务是**找到句柄 (Handle)** 并进行规约。算符优先分析法提供了一种简单直观的策略：**通过比较运算符之间的优先级来“框定”句柄的边界**。为了让这个策略行得通，我们必须在一套非常严格的“游戏规则”下进行。

---
**核心场景：分析句子 `a + b * c`**

*   **正确的语法结构**: `a + (b * c)`
*   **正确的句柄**: 在 `a+b*c` 中，第一个句柄是 `b`，然后是 `c`，然后是 `b*c`...  不，最直观的句柄应该是 `b*c` 这个整体。
*   **我们的目标**: 设计一种机制，能让计算机自动发现 `b*c` 是一个应该被优先“打包”（规约）的整体。

---

#### **1.1 准入许可证：算符文法 (Operator Grammar)**

不是所有的文法都有资格参与“算符优先”这个游戏。只有满足特定条件的**算符文法**才能入场。


**算符优先文法的条件：**
1.  **没有 `A → BC` 这种相邻的非终结符。**
2.  **没有 `A → ε` 产生式。**

**为什么要有这些条件？**
> 为什么如果允许 A → BC，分析器就找不到“路牌”了？为什么只有算符文法才能入场？

我们来做一个思想实验，假设我们**违反**了算符文法的规定。

*   **一个“坏”的文法 (非算符文法)**:
    1.  `E → T | E + T`
    2.  `T → F | T F`  (**违反！** `T` 和 `F` 两个非终结符相邻)
    3.  `F → id`

*   **一个推导过程**: `E ⇒ E+T ⇒ E+TF ⇒ E+Tid ⇒ E+Fid ⇒ E+idid ⇒ ...`
    *   在某个中间句型中，我们可能得到 `...id id...` 这样的结构，其中第一个 `id` 来自 `T`，第二个 `id` 来自 `F`。

**现在，我们来构造优先关系表。**
我们要确定 `id` 和 `id` 之间的关系。算法要求我们去文法里找模式。
*   我们找到了 `T → T F` 这条规则。
*   算法想确定 `LASTVT(T)` 和 `FIRSTVT(F)` 之间的关系。
    *   `LASTVT(T)` 包含 `id`。
    *   `FIRSTVT(F)` 包含 `id`。
*   但是，在 `T` 和 `F` 之间，**没有任何终结符**！我们的构造规则（`...aP...`, `...Pa...`, `...aPb...`）**全都用不上**！
    *   `a<∙b` 的规则是 `...aP...`，`a` 和 `P` 之间没有东西。
    *   `b∙>a` 的规则是 `...Pa...`，`P` 和 `a` 之间没有东西。
*   **结果**: 算法在 `T` 和 `F` 之间找不到任何“路牌”（终结符），因此**无法定义** `LASTVT(T)` 中的终结符和 `FIRSTVT(F)` 中的终结符之间的优先关系。优先关系表 `M[id, id]` 将是一个**空白格**。

**回到分析过程**:
当分析器处理 `...id * id...` 时（假设乘法用 `TF` 表示），栈顶是 `id`，输入是 `id`。分析器去查表 `M[id, id]`，发现是**空的**！它不知道该移入还是规约，程序卡住了。

**结论**:
“**不允许 `A → BC`**” 这个规定，就是为了从根本上杜绝这种“**关系真空**”的出现。它强制要求任意两个非终结符之间必须由一个终结符隔开（`A → B a C`）。这个 `a`，就成了 `B` 的结尾和 `C` 的开头之间的“**关系联络员**”或“**路牌**”，使得优先关系可以被明确地定义出来。

所以，只有算符文法才能保证我们能构造出一张**没有空白格**的、完整的优先关系表。这就是它的“入场券”。

---

#### **1.2 导航路牌：三种优先关系**

算符优先分析器的所有决策，都依赖于比较“栈顶终结符”和“当前输入符”这两种关系。

*   **`a <∙ b` (移入优先)**：`a` 的优先级低于 `b`。意味着一个更高优先级的语法结构以 `b` 开始了。**动作：移入**。
*   **`a ∙> b` (规约优先)**：`a` 的优先级高于 `b`。意味着以 `a` 结尾的一个高优先级语法结构已经完整了（句柄的尾部找到了）。**动作：规约**。
*   **`a ∙= b` (同级优先)**：`a` 和 `b` 是同一个语法结构的一部分，比如括号 `()`。**动作：移入**。

#### **1.3 核心特性：不对称性**

> **虽然有 `t₁ ∙> t₂`，不一定有 `t₂ <∙ t₁`。**

*   **为什么？** 因为 `<∙` 和 `∙>` 回答的是两个**完全不同**的问题。
    *   **`t₂ <∙ t₁` 问的是**：“当我看到 `t₂`，后面又来了 `t₁` 时，我是不是该**开启**一个由 `t₁` 主导的新结构？” (例如 `+` 遇到 `*`)
    *   **`t₁ ∙> t₂` 问的是**：“当我看到 `t₁`，后面又来了 `t₂` 时，是不是标志着我 (`t₁`) 所在的这个结构已经可以**结束**了？” (例如 `*` 遇到 `+`)
*   一个是“**开启**”的判断，一个是“**结束**”的判断。这两个判断的场景和逻辑都不同，所以它们的关系不是简单的数学大小比较，**不是对称的**。


---


#### 2.2 算符优先分析

想象一下，你正在编写一个只能处理简单加减乘除的计算器程序。你的任务是，拿到一个像 `id + id * id` 这样的、没有括号的 Token 序列，然后正确地计算出结果。

你的大脑知道应该“先算乘法，后算加法”。**算符优先分析法，就是把这个直觉“算法化”的一套机制。**

#### **核心思想：用“优先级”确定运算边界**

自下而上分析的核心是找到**句柄 (Handle)** 并进行规约。算符优先分析法认为，一个由运算符和操作数构成的句柄，它的边界一定是由**优先级的变化**来确定的。

*   当优先级**持续升高**时（比如 `+` 后面遇到 `*`），说明我们还在“爬坡”，句柄还没完整，应该继续向后看。
*   当优先级**突然下降**时（比如 `*` 后面遇到 `+`），说明“爬坡”结束了，一个高优先级的“山顶”（句柄）已经形成，是时候把它处理掉了（规约）。

#### **第一步：定义“路况”——三种优先关系**

为了将“优先级变化”这个概念形式化，我们定义了任意两个**终结符**（我们称之为“算符”）`θ₁` 和 `θ₂` 之间的三种关系：

1.  **`θ₁ <∙ θ₂` (移入优先)**
    *   **含义**: `θ₁` 的优先级**低于** `θ₂`。
    *   **比喻**: 遇到了一个**上坡路** `( `。
    *   **决策**: 句柄尚未形成，应该将 `θ₂` **移入 (Shift)** 栈中，继续前进。
    *   **例子**: `... + * ...`  =>  `+ <∙ *`

2.  **`θ₁ ∙> θ₂` (规约优先)**
    *   **含义**: `θ₁` 的优先级**高于** `θ₂`。
    *   **比喻**: 遇到了一个**下坡路** `) `。
    *   **决策**: 以 `θ₁` 结尾的句柄已经在栈顶形成，应该立即进行**规约 (Reduce)**。
    *   **例子**: `... * + ...`  =>  `* ∙> +`

3.  **`θ₁ ∙= θ₂` (同级优先)**
    *   **含义**: `θ₁` 和 `θ₂` 属于同一个句柄的“内部”。
    *   **比喻**: 在一段**平路**上行驶 ` = `。
    *   **决策**: 句柄还未完整，继续**移入**。
    *   **例子**: `( ... )` 或 `if ... then`  =>  `( ∙= )` , `if ∙= then`

#### **第二步：绘制“导航图”——构造算符优先关系表**

为了让分析器能快速查询这些关系，我们需要预先计算出一张二维表。

**前提条件**: 文法必须是**算符文法**（没有 `A→BC` 或 `A→ε`）。

**构造工具**: `FIRSTVT(P)` 和 `LASTVT(P)` 集合。
*   `FIRSTVT(P)`: `P` 能推导出的**第一个终结符**的集合。
*   `LASTVT(P)`: `P` 能推导出的**最后一个终结符**的集合。

**构造规则 (遍历所有产生式)**:
*   **寻找 `<∙` (上坡)**: 找 `...θ₁ P...` 结构，对于 `FIRSTVT(P)` 中的每个 `θ₂`，置 `θ₁ <∙ θ₂`。
*   **寻找 `∙>` (下坡)**: 找 `...P θ₁...` 结构，对于 `LASTVT(P)` 中的每个 `θ₂`，置 `θ₂ ∙> θ₁`。
*   **寻找 `∙=` (平路)**: 找 `...θ₁ θ₂...` 或 `...θ₁ P θ₂...` 结构，置 `θ₁ ∙= θ₂`。

#### **第三步：开始“驾驶”——算符优先分析算法**

现在，我们有了“导航图”（优先表），可以开始分析输入了。

**工作台**:
*   一个**符号栈**，栈底预置一个边界符 `$`。
*   一个**输入队列**，末尾预置一个边界符 `$`。

**算法流程**:

1.  **初始化**: `$` 入栈。
2.  **主循环**:
    a.  设 `k` 是栈顶的第一个终结符，`a` 是当前输入符号。
    b.  查询 `k` 和 `a` 的优先关系 `k ? a`。

    c.  **case `k <∙ a` 或 `k ∙= a`**:  // 上坡或平路
        i.  **移入 (Shift)**: 将 `a` 压入栈中。
        ii. 输入指针后移一位。

    d.  **case `k ∙> a`**: // 下坡，该规约了！
        i.  **寻找句柄**: 从栈顶开始，向栈底扫描，找到**最近的**一个终结符 `j`，使得 `j <∙ k`。
        ii. 句柄就是 `j` 和 `k` 之间的所有内容（包括 `k`，不包括 `j`）。
        iii. **规约 (Reduce)**: 将这个句柄从栈中弹出，然后压入一个**通用的非终结符**（比如 `N`）。
        iv. **注意**: **输入指针保持不动**，因为 `a` 还没有被处理，它将是下一轮比较的对象。

    e.  **case `关系为空` (error)**:
        i.  报告语法错误。

    f.  **case `k = $` 且 `a = $`**:
        i.  **接受 (Accept)**: 分析成功，结束。

#### **第四步：一个完整的例子**

*   **文法**: `E → E+T | T`, `T → T*F | F`, `F → id`
*   **输入**: `id + id * id $`
*   **优先关系 (部分)**: `+ <∙ *`, `* ∙> +`, `+ ∙> $`, `* ∙> $`, `$ <∙ id` ...

**模拟过程**:

| 栈 | 优先关系 | 输入 | 动作 |
| :--- | :--- | :--- | :--- |
| `$` | `$ <∙ id` | `^id + id * id $` | 移入 `id` |
| `$ id` | `id ∙> +` | `  ^+ id * id $` | 规约 `id` -> `N` |
| `$ N` | `$ <∙ +` | `  ^+ id * id $` | 移入 `+` |
| `$ N +` | `+ <∙ id` | `    ^id * id $` | 移入 `id` |
| `$ N + id`| `id ∙> *` | `      ^* id $` | 规约 `id` -> `N` |
| `$ N + N` | `+ <∙ *` | `      ^* id $` | 移入 `*` |
| `$ N + N *`| `* <∙ id` | `        ^id $` | 移入 `id` |
| `$ N+N*id`| `id ∙> $` | `           ^$` | 规约 `id` -> `N` |
| `$ N+N*N` | `* ∙> $` | `           ^$` | 规约 `N*N` -> `N` |
| `$ N + N` | `+ ∙> $` | `           ^$` | 规约 `N+N` -> `N` |
| `$ N` | `$ ∙= $` | `           ^$` | 接受！(这里假设 `$= $` 是接受) |

**注意**: 在实际算法中，栈里会同时有终结符和非终结符。比较时，我们会从栈顶向下找到第一个终结符。


---
#### **1. 素短语 (Prime Phrase)**

*   **定义**: 一个算符文法的句型中的一个子串，如果它至少包含一个终结符，并且它本身的两侧是具有更高优先级的终结符，或者它已经是整个句型的边界，那么这个子串就称为**素短语**。
    *   更形式化的说，对于句型 `...a S b...`，如果 `a <∙ S的第一个终结符` 且 `S的最后一个终结符 ∙> b`，那么`S`就是一个素短语。

*   **直观理解 (用“括号匹配”思想)**:
    > **素短语就是由一对 `<∙` 和 `∙>` 像括号一样“包”起来的、<u>最长</u>的那个符号串。**

*   **例子**:
    *   句子: `$ id + id * id $`
    *   优先关系链: `$ <∙ id ∙> + <∙ id ∙> * <∙ id ∙> $`
    *   我们来找 `<∙ ... ∙>` 这种模式：
        *   `$ <∙ id ∙> +`：`id` 是一个素短语。
        *   `+ <∙ id ∙> *`：`id` 是一个素短语。
        *   `* <∙ id ∙> $`：`id` 是一个素短语。
    *   如果我们已经规约了一部分，比如得到了 `$ N + N * N $`
    *   优先关系链: `$ <∙ + <∙ * ∙> $` (这里忽略了非终结符)
    *   我们找到了 `<∙ * ∙>` 这个模式。在栈里，它对应的是 `N*N`。所以 `N*N` 是一个素短语。

#### **2. 最左素短语 (Leftmost Prime Phrase)**

*   **定义**: 在一个句型中，**最左边的那个素短语**。
*   **核心关系**:
    > **最左素短语，就是算符优先分析中的“句柄”。**

*   **为什么？**
    *   算符优先分析算法的工作流程，就是不断地寻找**优先级最高的区域**并进行规约。
    *   这个“最高优先级”的区域，在符号串上就表现为由 `<∙` 和 `∙>` 包围的结构。
    *   由于我们是从左到右扫描的，我们找到的**第一个**完整的 `<∙ ... ∙>` 结构，自然就是**最左边的那个素短语**。

*   **算法的体现**:
    *   算符优先分析算法中，“**当 `k ∙> a` 时开始在栈中回溯查找最近的 `<∙`**” 这个动作，就是在**定位最左素短语（句柄）的边界**。

**总结**:
*   **素短语**是算符优先分析法能够识别的“语法单元”，是“短语”概念在算符文法中的一种简化替代品。
*   **最左素短语**就是分析器在每一步中要寻找的**句柄**。

---

#### 2.4 优缺点总结

*   **优点**:
    1.  **实现简单**: 算法逻辑直观，核心就是查表和比较，很容易手动实现。
    2.  **效率高**: 分析过程是线性的。
    3.  **擅长处理表达式**: 对于以中缀表示的算术表达式和逻辑表达式，这种方法非常有效。

*   **缺点**:
    1.  **能分析的文法有限**: 必须是算符文法，这排除了很多常见的语法结构。
    2.  **“假装”规约**: 它只能找到句柄的边界，但**无法确定**应该用哪一条产生式进行规约。因此，它**不能**用于构造详细的语法树，通常只能得到一个运算符的执行序列。
    3.  **错误处理能力弱**: 发现错误后，恢复起来比较困难。

---
### **补充三：优先函数 (Precedence Functions)**

我们之前讨论的**优先关系表**，在实现时有几个缺点：
1.  **占用空间大**: 如果有 `n` 个终结符，就需要一个 `n x n` 的二维数组来存储。
2.  **查找效率**：虽然查表很快，但还有提升空间。
3.  **构造复杂**：计算 `FIRSTVT` 和 `LASTVT` 有些繁琐。

**优先函数**提供了一种更优雅、更高效的替代方案。

*   **核心思想**:
    > 我们不存储两两之间的关系，而是为**每一个终结符** `θ` 分别赋予两个**整数值**：
    > *   **`f(θ)`**: 栈内优先函数 (In-Stack Precedence, ISP)
    > *   **`g(θ)`**: 栈外优先函数 (In-Coming Precedence, ICP)
    >
    > 然后，通过比较这两个整数的大小，来**动态地推导出**优先关系。

*   **推导规则**:
    *   如果栈顶终结符是 `θ₁`，当前输入是 `θ₂`：
        *   若 **`f(θ₁) < g(θ₂)`**，则 `θ₁ <∙ θ₂` (移入)。
        *   若 **`f(θ₁) > g(θ₂)`**，则 `θ₁ ∙> θ₂` (规约)。
        *   若 **`f(θ₁) = g(θ₂)`**，则 `θ₁ ∙= θ₂` (移入，通常用于括号)。

*   **`f` 和 `g` 的直观理解**:
    *   `f(θ)` (栈内/左边) 代表了这个运算符作为**一个运算的结尾**时的“坚守能力”。
    *   `g(θ)` (栈外/右边) 代表了这个运算符作为**一个运算的开始**时的“抢占能力”。

*   **一个经典的例子 (加减乘除)**:
    | 符号 θ | `f(θ)` (栈内) | `g(θ)` (栈外) |
    | :--- | :--- | :--- |
    | `+`, `-` | 2 | 1 |
    | `*`, `/` | 4 | 3 |
    | `(` | 0 | 5 |
    | `)` | - | 0 |
    | `id` | 6 | 5 |
    | `$` | 0 | 0 |

*   **我们来验证一下**:
    *   **比较 `+` (栈内) 和 `*` (栈外)**:
        *   `f(+) = 2`, `g(*) = 3`。
        *   `f(+) < g(*)` => `+ <∙ *` (移入)。**正确！**
    *   **比较 `*` (栈内) 和 `+` (栈外)**:
        *   `f(*) = 4`, `g(+) = 1`。
        *   `f(*) > g(+)` => `* ∙> +` (规约)。**正确！**
    *   **比较 `(` (栈内) 和 `id` (栈外)**:
        *   `f(() = 0`, `g(id) = 5`。
        *   `f(() < g(id)` => `( <∙ id` (移入)。**正确！**
    *   **比较 `+` (栈内) 和 `+` (栈外) (处理左结合性)**:
        *   `f(+) = 2`, `g(+) = 1`。
        *   `f(+) > g(+)` => `+ ∙> +` (规约)。这意味着 `a+b+c` 会被解析成 `(a+b)+c`，因为看到第二个 `+` 时，会先规约前面的 `a+b`。

**总结**:
*   **优先函数**是**优先关系表**的一种**压缩存储和高效实现**。
*   它将 `n x n` 的关系查询，变成了两次函数调用和一次整数比较。
*   **但请注意**：**并非所有**的算符优先关系表都能找到对应的优先函数。只有当优先关系图中不存在“环路”（比如 `a <∙ b`, `b <∙ c`, `c <∙ a`）时，才能构造出优先函数。
---

### **第三讲：LR 分析入门 —— 引擎与地图**

**我们的起点**：算符优先分析法虽然简单，但它是个“半成品”——它只能找到句柄的**边界**，却不知道该用哪条规则**规约**，而且能处理的文法非常有限。

**LR 分析法的伟大之处**：它是一个**全能型**的自下而上分析器。它不仅能准确地找到句柄，还能**精确地告诉你**在当前情况下应该用哪一条产生式来规约。它能处理的文法范围比所有其他方法都要广。

---
#### **3.1 LR 分析器的通用模型 (The Engine)**

一个 LR 分析器，无论它是 LR(0), SLR(1), LR(1) 还是 LALR(1)，它的**基本结构**和**工作流程**都是完全一样的。它们就像同一款式的汽车，只是搭载了不同型号的发动机（分析表）。

**LR 分析器的四大核心组件**：

1.  **输入缓冲区 (Input Buffer)**:
    *   存放着词法分析器生成的、末尾添加了 `$` 的 Token 序列。

2.  **分析栈 (Parsing Stack)**:
    *   这是 LR 分析器与 LL 分析器栈的最大不同之处。
    *   LR 的栈里存放的不是文法符号，而是**状态编号 (State Number)**。
    *   栈底是初始状态 `0`。栈顶的状态，代表了分析器**当前所处的状态**。
    *   这个“状态”包含了识别到目前为止的所有语法信息。

3.  **总控程序 (Driver Program)**:
    *   这是一个固定的、通用的算法。它不依赖于任何具体文法。
    *   它的工作就是不断地查看**栈顶状态 `s`** 和**当前输入符号 `a`**，然后去查询“大脑”，决定下一步该做什么。

4.  **LR 分析表 (The Map)**:
    *   这是 LR 分析器的“**大脑**”和“**地图**”，是整个引擎的核心。它是一个二维表，由两部分构成：
        *   **ACTION 表**:
            *   **行**: 状态 `s`
            *   **列**: 终结符 `a`
            *   **内容 `ACTION[s, a]`**: 指示了下一步要执行的**四种动作**之一。
        *   **GOTO 表**:
            *   **行**: 状态 `s`
            *   **列**: 非终结符 `A`
            *   **内容 `GOTO[s, A]`**: 指示了在一次规约完成后，应该**转移到哪个新状态**。

---
#### **3.2 四种动作详解**

总控程序根据查询 `ACTION[栈顶状态, 当前输入]` 的结果，来执行以下四种动作之一：

1.  **移入 (Shift s')**:
    *   **指令**: `shift s'` (或 `s s'`)
    *   **动作**:
        a.  将新的状态号 `s'` 压入栈顶。
        b.  将输入指针后移一位。
    *   **含义**: 当前的输入符号已经被“接受”，并导致了状态的转换。我们还需要继续向后看，句柄还没有完全形成。

2.  **规约 (Reduce r)**:
    *   **指令**: `reduce r` (或 `r r`)，其中 `r` 是产生式的编号（例如，第`r`条产生式是 `A → β`）。
    *   **动作**:
        a.  假设产生式右部 `β` 的长度是 `len`。
        b.  从栈中**弹出 `len` 个状态**。
        c.  此时，新的栈顶状态变成了 `s_new`。
        d.  查询 **`GOTO[s_new, A]`**，得到一个新状态 `s_goto`。
        e.  将 `s_goto` 压入栈顶。
        f.  **注意：输入指针保持不动！**
    *   **含义**: 栈顶已经形成了一个完整的句柄 `β`。我们现在将它规约为 `A`，然后根据 `GOTO` 表，跳转到因识别出 `A` 而应进入的新状态。

3.  **接受 (Accept)**:
    *   **指令**: `acc`
    *   **动作**: 宣布语法分析成功，程序终止。
    *   **含义**: 整个输入已经被成功地规约到了开始符号。

4.  **报错 (Error)**:
    *   **指令**: 空白单元格
    *   **动作**: 调用错误恢复程序。
    *   **含义**: 在当前状态下，根本不应该看到这个输入符号，输入不合法。

---
#### **3.3 LR 分析过程模拟**

让我们用一个（目前还不存在的）分析表，来模拟分析 `id * id $` 的过程。
*   **文法**: (1) `E → E * B`, (2) `E → B`, (3) `B → id`
*   **假设的分析表 (部分)**:
    *   `ACTION[0, id] = s2` (移入，并转到状态2)
    *   `ACTION[2, *] = r3` (按规则3 `B→id` 规约)
    *   `GOTO[0, B] = 1`
    *   ...

**模拟开始**:

| 步骤 | 状态栈 | 输入 | 动作 |
| :--- | :--- | :--- | :--- |
| 1 | `[0]` | `^id * id $` | `ACTION[0, id]=s2` -> **移入 2** |
| 2 | `[0, 2]` | `  ^* id $` | `ACTION[2, *]=r3` -> **按 `B→id` 规约** |
| | (弹出1个状态 `2`) | `  ^* id $` | 新栈顶是`0`。查`GOTO[0, B]=1` |
| 3 | `[0, 1]` | `  ^* id $` | (规约完成，回到决策点) |
| ... | ... | ... | ... |

这个模拟过程，清晰地展示了分析器是如何像一台精密的机器一样，完全依赖于**栈顶状态**和**当前输入**，通过查表来驱动整个分析流程的。

---


好的，你提醒得非常及时！这两个概念确实是算符优先分析理论中不可或缺的部分，特别是**优先函数**，它是在工程实践中替代“优先表”的一种更高效的实现方式。

我立刻为你补充这一部分的内容，并确保它能和你之前理解的“括号匹配”、“上下坡”等概念无缝衔接。

---





