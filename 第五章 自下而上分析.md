
---

### 第一讲：自下而上分析的核心思想 —— “搭积木”

#### 1.1 核心动作：移入-规约 (Shift-Reduce)

自下而上分析器的工作过程，可以用一个非常简单的循环来描述，这个循环只包含两种基本动作：

1.  **移入 (Shift)**：
    *   **动作**：将输入队列的**第一个** Token，移动到**分析栈**的顶部。
    *   **比喻**：从零件盒里，拿一个最基本的乐高积木，放到你的工作台上。

2.  **规约 (Reduce)**：
    *   **动作**：当分析栈顶部的**一串符号**，正好匹配了某个产生式规则的**右部**时，就将这串符号从栈中**弹出**，然后将该规则的**左部非终结符**压入栈中。
    *   **比喻**：你发现工作台上的几块积木（比如：轮胎、轮毂、车轴），正好可以拼成一个“车轮”部件。于是你把这些零散积木拿走，换上一个已经组装好的“车轮”部件。你完成了一次**抽象**。

**整个分析过程**，就是在这两种动作之间不断抉择，直到最终栈里只剩下开始符号 `S`，并且输入也被耗尽，此时分析成功。

---
#### 1.2 核心概念：规约 (Reduction)

**规约，就是推导的“逆过程”。**

*   **推导 (Derivation)**：`E ⇒ E + T` (把 `E` 展开成 `E+T`)
*   **规约 (Reduction)**：`E + T ⇒ E` (把 `E+T` 归结为 `E`)

**自下而上分析，本质上就是一个不断寻找“可规约子串”并进行规约的过程。**

**例子**:
*   **文法**: `S → aABe`, `A → Abc | b`, `B → d`
*   **输入**: `abcbde`
*   **一个可能的规约序列**:
    `abcbde`
    `aAbcde`  (将 `b` 规约为 `A`)
    `aAde`    (将 `Abc` 规约为 `A`)
    `aABe`    (将 `d` 规约为 `B`)
    `S`       (将 `aABe` 规约为 `S`) -> **分析成功！**

**但是，新的问题来了：在每一步，我们怎么知道应该规约哪一部分呢？**
*   在 `abcbde` 中，第一个 `b` 是一个合法的可规约项。
*   在 `aAbcde` 中，`Abc` 是一个合法的可规约项。

这个“在当前这一步，最应该被规约的子串”，有一个专门的名字，叫做**句柄 (Handle)**。

**什么是句柄？**
> **句柄是<u>最右推导</u>的逆过程。** 在一个句型中，句柄是与某个产生式右部匹配的子串，将它规约为该产生式的左部非终结符，可以得到上一步的最右句型。

**简单理解**：句柄就是“**正确的、不会导致我们走入死胡同的**”那个可规约子串。自下而上分析的**全部挑战**，就在于如何**准确地找到句柄**。

---
#### 1.3 终极目标：规范规约 (Canonical Reduction)

一个最完美的自下而上分析过程，就是**规范规约**。它指的是，分析的每一步都是**最右推导的精确逆过程**。

*   **最右推导**: 
<img width="1419" height="886" alt="image" src="https://github.com/user-attachments/assets/7872237d-b4dc-4d08-8474-8462a9dfdf71" />

*   **规范规约**:
  <img width="1413" height="807" alt="image" src="https://github.com/user-attachments/assets/c819d679-970a-4882-91f8-fb277fecad80" />

将待规约句型从左向右入栈，对应其最右推导语法树的最左叶子到最右叶子，一旦发现栈顶有可规约项就是也就是最左的2层子树也就是句柄就规约，也就是将该语法树的这个子树的叶子归约到子树根节点
**寻找句柄的挑战**:
*   我们怎么知道 `abcbde` 的句柄是第一个 `b`，而不是第二个 `b`？
*   我们怎么知道 `aAbcde` 的句柄是 `Abc`，而不是 `b`？

不同的分析方法，提供了不同的寻找句柄的策略：
*   **算符优先分析法**：通过比较运算符之间的优先级来“框定”句柄的边界。
*   **LR 分析法**：通过一个强大的 DFA（状态机）来精确地识别句柄的出现，并决定何时进行规约。这是最通用、最准确的方法。

---
#### 1.4 工作台：符号栈

为了实现“移入-规约”这个过程，并有效地追踪我们已经“拼好”的部件，我们需要一个**符号栈**。

**工作流程**:
1.  **初始状态**: 栈为空，输入指针指向第一个 Token。
2.  **循环**:
    a.  **决策**: 分析器根据当前**栈顶的状态**和**下一个输入 Token**，来决定是“移入”还是“规约”。（决策的依据，就是不同分析方法的核心，比如 LR 分析表）。
    b.  **执行“移入”**: 从输入队列拿一个 Token，压入栈顶。
    c.  **执行“规约”**:
        i.  在栈顶找到句柄（比如 `αβ`）。
        ii. 把它从栈顶弹出。
        iii. 把对应的产生式左部非终结符 `A` 压入栈顶。
3.  **结束**:
    *   **成功**: 当栈里只剩下开始符号 `S`，且输入队列为空时，分析成功。
    *   **失败**: 如果在某个决策点，分析器发现既不能移入，也不能规约，则报告语法错误。

---
### 补充一：短语、直接短语与句柄 (与语法树的关系)

这些概念都是**基于语法树**来定义的，它们描述了语法树中不同“片段”的层次关系。

**我们先来看一棵语法树：**

*   **文法**: `E → E * T | T`, `T → T + F | F`, `F → id`
*   **句子**: `id * id + id`
*   **它的一个最右推导**: `E ⇒ E*T ⇒ E*T+F ⇒ E*T+id ⇒ E*F+id ⇒ E*id+id ⇒ T*id+id ⇒ F*id+id ⇒ id*id+id`

**对应的语法树：**
```
      E
      |
      E -- * -- T
      |       |
      T       T -- + -- F
      |       |       |
      F       F      id
      |       |
      id      id
```

**现在，我们来定义这些概念：**

#### 1. 短语 (Phrase)

*   **定义**: 语法树中的**任一棵子树**，其**所有末端节点 (叶子)** 从左到右连接起来形成的字符串，就是相对于该子树根节点的一个**短语**。
*   **直观理解**: 短语就是句子中一个**语法上可以被看作一个整体**的部分。
*   **例子 (看上面的树)**:
    *   以最顶层的 `E` 为根的子树，它的叶子是 `id * id + id`。所以 `id * id + id` 是 `E` 的一个短语。
    *   以中间的 `T` 为根的子树，它的叶子是 `id + id`。所以 `id + id` 是 `T` 的一个短语。
    *   以最左边的 `F` 为根的子树，它的叶子是 `id`。所以第一个 `id` 是 `F` 的一个短语。

#### 2. 简单短语 (Simple Phrase)

*   **定义**: 如果一棵子树的**高度只有2** (即根节点直接连接所有叶子节点)，那么这棵子树的叶子形成的短语，就叫做**简单短语**。
*   **直观理解**: 简单短语是一个**一步推导**就能得到的短语。它正好对应某个产生式的**右部**。
*   **例子**:
    *   `E → T` 这棵子树（最左边的 `E` 和 `T`），它的叶子是 `T` 的叶子，即 `id`。但它的高度不是2。
    *   `T → F` 这棵子树（最左边的 `T` 和 `F`），叶子是`id`。也不是。
    *   `F → id` 这棵子树，高度是2！所以，`id` 是一个简单短语。
    *   `T → T + F` 这棵子树，它的叶子是 `id + id`。但它的高度超过2了，所以 `id+id` 不是简单短语。

#### 3. 句柄 (Handle)

*   **PPT 的定义**: “**最左简单短语**”。
*   **定义**: 一个句型的**句柄**，是这个句型所对应的语法树中，**最左边的那棵高度为2的子树**的叶子节点串。
*   **直观理解**: 句柄就是当前这一步，**最应该被规约**的那个部分。它对应了**最右推导的逆过程**。
*   **为什么是最左？** 因为我们是从左到右扫描输入的，我们最先遇到的那个可以被一步规约的完整单元，就是我们当前能处理的句柄。
*   **例子**:
    *   对于句型 `id * id + id`，它的语法树中，最左边的、高度为2的子树是 `F → id`。所以，**第一个 `id` 就是句柄**。
    *   规约后，句型变成 `F * id + id`。
    *   对于 `F * id + id`，最左的简单短语是 `F` 本身（来自`T->F`）。规约后得到 `T * id + id`。
    *   ... 这个过程不断进行，每一次都规约“最左简单短语”，就是在模拟最右推导的逆过程。

**总结**：`短语 > 简单短语 > 句柄`。句柄是简单短语中最特殊、最靠左的一个，它是自下而上分析器每一轮的“操作目标”。

---
### 第二讲：算符优先分析 —— 一个简单的“热身”

#### 2.1 适用范围：算符文法 (Operator Grammar)

算符优先分析法并**不能**用于所有的文法，它对文法有特殊的要求，这种文法被称为**算符文法**。

**算符文法的定义**：
一个文法是算符文法，如果它**不包含**以下两种形式的产生式：
1.  **右部有两个相邻的非终结符**。例如 `A → BC` 是**不允许**的。
2.  **右部为空** (`ε`)。例如 `A → ε` 是**不允许**的。

**为什么有这个限制？**
*   因为这种分析方法的核心，就是比较**终结符（操作符）**之间的优先关系。
*   如果两个非终结符 `B` 和 `C` 挨在一起，它们之间没有终结符，分析器就不知道该比较谁和谁的优先级了，方法失效。
*   `ε` 的存在会使句柄的边界变得模糊，因此也不允许。

**例子**:
*   `E → E + T | T`  => **是**算符文法 (非终结符 `E`, `T` 被终结符 `+` 分隔)。
*   `S → SS`        => **不是**算符文法 (两个 `S` 相邻)。
*   `A → aB | ε`      => **不是**算符文法 (有 `ε` 产生式)。

---
#### 2.2 核心工具：算符优先关系

算符优先分析法的“大脑”，就是一张**任意两个终结符之间的优先关系表**。

**三种优先关系** (设 `t₁` 和 `t₂` 是两个终结符)：

1.  **`t₁ ∙> t₂` (t₁ 的优先级高于 t₂) **
    *   **含义**: 当分析器在栈里看到 `t₁`，而下一个输入是 `t₂` 时，这强烈暗示着，以 `t₁` 为结尾的**句柄**已经在栈顶形成了，是时候进行**规约**了。
    *   **例子**: `id * id + id`。当看到 `*` 和 `+` 时，我们知道 `*` 的优先级高，所以 `id*id` 这部分应该先被规约。

2.  **`t₁ <∙ t₂` (t₁ 的优先级低于 t₂) **
    *   **含义**: 当栈顶附近是 `t₁`，而输入是 `t₂` 时，这暗示着句柄还没有形成，`t₂` 应该被**移入**栈中，继续向后看。
    *   **例子**: `id + id * id`。看到 `+` 和 `*` 时，`+` 优先级低，所以 `*` 和后面的 `id` 应该先被移入栈，等待形成更高优先级的 `id*id`。

3.  **`t₁ ∙= t₂` (t₁ 的优先级等于 t₂) **
    *   **含义**: `t₁` 和 `t₂` 属于同一个句柄的一部分。
    *   **例子**: `( E )`。 `(` 和 `)` 优先级相等，它们共同“包裹”了一个表达式。

**如何系统地构造优先关系表？**

这需要两个辅助集合，它们只针对**非终结符**计算：

*   **`FIRSTVT(P)`**: 非终结符 `P` 能推导出的、所有字符串**开头**的那个**终结符**的集合。
    *   (VT = Vocabulary of Terminals)
*   **`LASTVT(P)`**: 非终结符 `P` 能推导出的、所有字符串**结尾**的那个**终结符**的集合。

**构造规则 (遍历所有产生式)**：

1.  对于形如 `... t₁ t₂ ...` 或 `... t₁ P ...` 且 `t₂ ∈ FIRSTVT(P)` 的产生式右部：
    *   建立关系 **`t₁ <∙ t₂`**。
2.  对于形如 `... P t₁ ...` 且 `t₂ ∈ LASTVT(P)` 的产生式右部：
    *   建立关系 **`t₂ ∙> t₁`**。
3.  对于形如 `... t₁ t₂ ...` 或 `... t₁ P t₂ ...` 的产生式右部：
    *   建立关系 **`t₁ ∙= t₂`**。

---
#### 2.3 算符优先分析算法

这个算法非常直观，它使用一个符号栈，不断地比较“**栈顶的第一个终结符**”和“**当前输入符号**”之间的优先关系。

**算法流程**:
1.  在符号栈底和输入串末尾都加上一个特殊的低优先级界符 `$`。
2.  **循环**:
    a.  设 `a` 是栈顶的第一个终结符，`b` 是当前输入符号。
    b.  **`if a <∙ b` 或 `a ∙= b`**:
        *   **移入 (Shift)**。将 `b` 压入栈，输入指针后移。
    c.  **`else if a ∙> b`**:
        *   **规约 (Reduce)**。从栈顶向左，找到最左边的那个 `<∙` 关系，之间的所有内容就是句柄。
        *   对这个句柄执行一次（盲目的）规约，即将它替换成一个通用的非终结符（比如 `N`）。
        *   **注意**: 算符优先分析**不关心**具体用哪条产生式规约，它只关心句柄的**边界**。
    d.  **`else`**:
        *   **出错**。
3.  **结束**: 当栈中只剩下 `$ N $` (或 `$S$`) 时，分析成功。

---
#### 2.4 优缺点总结

*   **优点**:
    1.  **实现简单**: 算法逻辑直观，核心就是查表和比较，很容易手动实现。
    2.  **效率高**: 分析过程是线性的。
    3.  **擅长处理表达式**: 对于以中缀表示的算术表达式和逻辑表达式，这种方法非常有效。

*   **缺点**:
    1.  **能分析的文法有限**: 必须是算符文法，这排除了很多常见的语法结构。
    2.  **“假装”规约**: 它只能找到句柄的边界，但**无法确定**应该用哪一条产生式进行规约。因此，它**不能**用于构造详细的语法树，通常只能得到一个运算符的执行序列。
    3.  **错误处理能力弱**: 发现错误后，恢复起来比较困难。

---


### 补充二：算符优先分析的条件与原因

**算符优先文法的条件：**
1.  **没有 `A → BC` 这种相邻的非终结符。**
2.  **没有 `A → ε` 产生式。**

**为什么要有这些条件？**

这完全是由算符优先分析法的**工作原理**决定的。

*   **它的核心原理**: 通过比较**终结符**之间的优先关系，来找到句柄的边界。
*   **它的“视力”**: 这个分析器是个“**近视眼**”，它**看不见**非终结符。当它扫描 `...a A b B c...` 时，它眼中看到的就是 `...a b c...`。

**现在我们来看，违反条件会发生什么：**

1.  **如果存在 `A → BC`**:
    *   假设有一个产生式是 `S → a A b`，而 `A → BC`。
    *   那么推导过程是 `S ⇒ aAb ⇒ aBCb`。
    *   当分析器面对 `aBCb` 时，它在栈里看到的是 `...a`，下一个输入可能是 `b`（如果B和C推导出的东西都处理完了）。
    *   在 `B` 和 `C` 之间，**没有任何终结符**！分析器不知道该比较谁和谁的优先级。它在 `B` 的结尾和 `C` 的开头之间，**找不到可以用于比较的“界碑”**。它的方法完全失效了。

2.  **如果存在 `A → ε`**:
    *   假设有一个产生式 `S → a A b`，而 `A → ε`。
    *   那么推导是 `S ⇒ aAb ⇒ ab`。
    *   当分析器处理 `ab` 时，它看到了终结符 `a` 和 `b`。
    *   但是，在 `a` 和 `b` 之间，**“幽灵般”地存在一个 `A`**。这个 `A` 是句柄，应该被规约。
    *   但是，算符优先分析器**只看终结符**。它会去比较 `a` 和 `b` 的优先级，而完全**忽略**了中间那个空句柄 `A` 的存在。它找不到这个长度为0的句柄，因此无法进行正确的规约。

**结论**：这两个条件，都是为了保证在任意两个需要比较优先级的符号之间，**最多只有一个非终结符**，从而确保了**任意两个相邻的终结符**之间的优先关系，能够**唯一地**反映出它们之间的语法结构关系。这是算符优先分析法能够成功定位句柄的**根本前提**。
上。

---
### **第三讲：LR 分析入门 —— 引擎与地图**

**我们的起点**：算符优先分析法虽然简单，但它是个“半成品”——它只能找到句柄的**边界**，却不知道该用哪条规则**规约**，而且能处理的文法非常有限。

**LR 分析法的伟大之处**：它是一个**全能型**的自下而上分析器。它不仅能准确地找到句柄，还能**精确地告诉你**在当前情况下应该用哪一条产生式来规约。它能处理的文法范围比所有其他方法都要广。

---
#### **3.1 LR 分析器的通用模型 (The Engine)**

一个 LR 分析器，无论它是 LR(0), SLR(1), LR(1) 还是 LALR(1)，它的**基本结构**和**工作流程**都是完全一样的。它们就像同一款式的汽车，只是搭载了不同型号的发动机（分析表）。

**LR 分析器的四大核心组件**：

1.  **输入缓冲区 (Input Buffer)**:
    *   存放着词法分析器生成的、末尾添加了 `$` 的 Token 序列。

2.  **分析栈 (Parsing Stack)**:
    *   这是 LR 分析器与 LL 分析器栈的最大不同之处。
    *   LR 的栈里存放的不是文法符号，而是**状态编号 (State Number)**。
    *   栈底是初始状态 `0`。栈顶的状态，代表了分析器**当前所处的状态**。
    *   这个“状态”包含了识别到目前为止的所有语法信息。

3.  **总控程序 (Driver Program)**:
    *   这是一个固定的、通用的算法。它不依赖于任何具体文法。
    *   它的工作就是不断地查看**栈顶状态 `s`** 和**当前输入符号 `a`**，然后去查询“大脑”，决定下一步该做什么。

4.  **LR 分析表 (The Map)**:
    *   这是 LR 分析器的“**大脑**”和“**地图**”，是整个引擎的核心。它是一个二维表，由两部分构成：
        *   **ACTION 表**:
            *   **行**: 状态 `s`
            *   **列**: 终结符 `a`
            *   **内容 `ACTION[s, a]`**: 指示了下一步要执行的**四种动作**之一。
        *   **GOTO 表**:
            *   **行**: 状态 `s`
            *   **列**: 非终结符 `A`
            *   **内容 `GOTO[s, A]`**: 指示了在一次规约完成后，应该**转移到哪个新状态**。

---
#### **3.2 四种动作详解**

总控程序根据查询 `ACTION[栈顶状态, 当前输入]` 的结果，来执行以下四种动作之一：

1.  **移入 (Shift s')**:
    *   **指令**: `shift s'` (或 `s s'`)
    *   **动作**:
        a.  将新的状态号 `s'` 压入栈顶。
        b.  将输入指针后移一位。
    *   **含义**: 当前的输入符号已经被“接受”，并导致了状态的转换。我们还需要继续向后看，句柄还没有完全形成。

2.  **规约 (Reduce r)**:
    *   **指令**: `reduce r` (或 `r r`)，其中 `r` 是产生式的编号（例如，第`r`条产生式是 `A → β`）。
    *   **动作**:
        a.  假设产生式右部 `β` 的长度是 `len`。
        b.  从栈中**弹出 `len` 个状态**。
        c.  此时，新的栈顶状态变成了 `s_new`。
        d.  查询 **`GOTO[s_new, A]`**，得到一个新状态 `s_goto`。
        e.  将 `s_goto` 压入栈顶。
        f.  **注意：输入指针保持不动！**
    *   **含义**: 栈顶已经形成了一个完整的句柄 `β`。我们现在将它规约为 `A`，然后根据 `GOTO` 表，跳转到因识别出 `A` 而应进入的新状态。

3.  **接受 (Accept)**:
    *   **指令**: `acc`
    *   **动作**: 宣布语法分析成功，程序终止。
    *   **含义**: 整个输入已经被成功地规约到了开始符号。

4.  **报错 (Error)**:
    *   **指令**: 空白单元格
    *   **动作**: 调用错误恢复程序。
    *   **含义**: 在当前状态下，根本不应该看到这个输入符号，输入不合法。

---
#### **3.3 LR 分析过程模拟**

让我们用一个（目前还不存在的）分析表，来模拟分析 `id * id $` 的过程。
*   **文法**: (1) `E → E * B`, (2) `E → B`, (3) `B → id`
*   **假设的分析表 (部分)**:
    *   `ACTION[0, id] = s2` (移入，并转到状态2)
    *   `ACTION[2, *] = r3` (按规则3 `B→id` 规约)
    *   `GOTO[0, B] = 1`
    *   ...

**模拟开始**:

| 步骤 | 状态栈 | 输入 | 动作 |
| :--- | :--- | :--- | :--- |
| 1 | `[0]` | `^id * id $` | `ACTION[0, id]=s2` -> **移入 2** |
| 2 | `[0, 2]` | `  ^* id $` | `ACTION[2, *]=r3` -> **按 `B→id` 规约** |
| | (弹出1个状态 `2`) | `  ^* id $` | 新栈顶是`0`。查`GOTO[0, B]=1` |
| 3 | `[0, 1]` | `  ^* id $` | (规约完成，回到决策点) |
| ... | ... | ... | ... |

这个模拟过程，清晰地展示了分析器是如何像一台精密的机器一样，完全依赖于**栈顶状态**和**当前输入**，通过查表来驱动整个分析流程的。

---
。

