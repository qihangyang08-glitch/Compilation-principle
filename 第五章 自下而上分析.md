

---
### 小知识补充
#### 第一部分：句子 (Sentence) vs. 句型 (Sentential Form)

我们先来严格地区分这两个概念。

*   **句子 (Sentence)**:
    *   **定义**：从文法的**开始符号 `S`** 出发，经过一步或多步**推导**，最终得到的**只包含终结符**的字符串。
    *   **直观理解**：一个“句子”就是这个语言中一个**完整、合法、可以被用户写出来**的程序或语句。
    *   **例子**: 对于算术表达式文法，`id * id + id` 是一个句子。

*   **句型 (Sentential Form)**:
    *   **定义**：从文法的**开始符号 `S`** 出发，经过一步或多步**推导**，得到的**可以包含终结符和非终-结符**的字符串。
    *   **直观理解**：一个“句型”是推导过程中的一个“**中间快照**”或“**半成品**”。
    *   **例子**: 在推导 `id * id` 的过程中，我们可能会经过 `E ⇒ T ⇒ T * F ⇒ T * id`。这里的 `E`, `T`, `T * F`, `T * id` **都是句型**。

**两者的关系**：
> **所有的“句子”，都是“句型”的一种特殊情况。** 但“句型”不一定是“句子”。

---

#### 第二部分：如何证明一个字符串是该文法的句型？

> **“能用最左或最右推导得出的句子就是文法的一个句型吗？”**

**你的这句话基本正确，但需要更精确一点：**

> **只要一个字符串 `α` 能够从开始符号 `S` 通过<u>任意一种</u>合法的推导方式（不一定是最左或最右，也可以是混合的）得到，那么 `α` 就是该文法的一个句型。**

所以，要证明字符串 `α` 是文法 `G` 的一个句型，你只需要做一件事：

**给出一个从开始符号 `S` 到 `α` 的完整推导序列。**

#### **做题步骤：**

1.  **确定目标**: 你要证明的目标字符串是 `α`。
2.  **寻找路径 (逆向思维)**：
    *   从 `α` **倒着往回看**，寻找 `α` 中有没有某个子串，正好是某个产生式的**右部**。
    *   如果有，尝试用该产生式的**左部**去替换它，得到一个“更简单”的句型 `α'`。这个过程就是“**规约**”。
    *   对 `α'` 重复这个过程，直到你最终能规约到开始符号 `S`。
3.  **书写证明 (正向推导)**：
    *   把你刚刚“倒着找”的路径，**反过来写一遍**，就成了一个从 `S` 到 `α` 的**正向推导**过程。
    *   在每一步推导 `⇒` 旁边，最好注明你用的是哪一条产生式规则。

#### **一个具体的例子**

*   **文法 G**:
    1.  `E → E + T`
    2.  `E → T`
    3.  `T → T * F`
    4.  `T → F`
    5.  `F → (E)`
    6.  `F → id`

*   **题目**: 证明 `T * id + T` 是文法 G 的一个句型。

**1. 思考过程 (倒着规约)**:
*   目标: `T * id + T`
*   看到 `id`，它可以由 `F → id` 规约而来。我们试试： `T * F + T`。
*   看到 `T * F`，它可以由 `T → T * F` 规约而来。我们试试： `T + T`。
*   看到 `T + T`... 文法里没有 `E → T + T`，只有 `E → E + T`。
*   **这条路好像走不通。我们换一条路。**

*   目标: `T * id + T`
*   我们从右边看，`T` 可以由 `E → T` 规约而来。试试：`T * id + E`。
*   `id` 可以由 `F → id` 规约而来。试试：`T * F + E`。
*   `T * F` 可以由 `T → T * F` 规约而来。试试：`T + E`。
*   `T` 可以由 `E → T` 规约而来。试试：`E + E`。
*   `E + E`... 还是走不通。

*   **再换一条路！** 我们要找**最右推导**的逆过程。
*   目标: `T * id + T`
*   句柄是什么？可能是 `id`。规约 `F → id` => `T * F + T`。
*   新目标: `T * F + T`。句柄是什么？可能是 `T`。规约 `E → T` => `T * F + E`。
*   新目标: `T * F + E`。句柄是什么？可能是 `T*F`。规约 `T → T*F` => `T + E`。
*   新目标: `T + E`。句-柄是什么？可能是 `T`。规约 `E → T` => `E + E`。
*   **又卡住了！**

**这说明，有时候寻找推导路径并不容易。让我们尝试从 `S` (这里是`E`) 正向推导。**

**2. 书写证明 (正向推导)**

*   **目标**: `T * id + T`
*   **开始**: `E`
*   我们看到目标里有 `+`，所以第一步很可能要用 `E → E + T`。
    `E ⇒ E + T`  (使用规则 `E → E + T`)
*   现在我们需要把左边的 `E` 变成 `T * id`。
    `⇒ T + T`    (使用规则 `E → T`)
    `⇒ T * F + T` (使用规则 `T → T * F`)
    `⇒ T * id + T` (使用规则 `F → id`)

*   **找到了！** 我们成功地找到了一个从 `E` 到 `T * id + T` 的推导序列。

**最终的证明过程就是：**
> **证明**:
>
> `E ⇒ E + T` (依据 `E → E + T`)
>
> `⇒ T + T` (依据 `E → T`)
>
> `⇒ T * F + T` (依据 `T → T * F`)
>
> `⇒ T * id + T` (依据 `F → id`)
>
> 因为存在一个从开始符号 `E` 到 `T * id + T` 的推导，所以 `T * id + T` 是该文法的一个句型。

---

---

### 第一讲：自下而上分析的核心思想 —— “搭积木”

#### 1.1 核心动作：移入-规约 (Shift-Reduce)

自下而上分析器的工作过程，可以用一个非常简单的循环来描述，这个循环只包含两种基本动作：

1.  **移入 (Shift)**：
    *   **动作**：将输入队列的**第一个** Token，移动到**分析栈**的顶部。
    *   **比喻**：从零件盒里，拿一个最基本的乐高积木，放到你的工作台上。

2.  **规约 (Reduce)**：
    *   **动作**：当分析栈顶部的**一串符号**，正好匹配了某个产生式规则的**右部**时，就将这串符号从栈中**弹出**，然后将该规则的**左部非终结符**压入栈中。
    *   **比喻**：你发现工作台上的几块积木（比如：轮胎、轮毂、车轴），正好可以拼成一个“车轮”部件。于是你把这些零散积木拿走，换上一个已经组装好的“车轮”部件。你完成了一次**抽象**。

**整个分析过程**，就是在这两种动作之间不断抉择，直到最终栈里只剩下开始符号 `S`，并且输入也被耗尽，此时分析成功。

---
#### 1.2 核心概念：规约 (Reduction)

**规约，就是推导的“逆过程”。**

*   **推导 (Derivation)**：`E ⇒ E + T` (把 `E` 展开成 `E+T`)
*   **规约 (Reduction)**：`E + T ⇒ E` (把 `E+T` 归结为 `E`)

**自下而上分析，本质上就是一个不断寻找“可规约子串”并进行规约的过程。**

**例子**:
*   **文法**: `S → aABe`, `A → Abc | b`, `B → d`
*   **输入**: `abcbde`
*   **一个可能的规约序列**:
    `abcbde`
    `aAbcde`  (将 `b` 规约为 `A`)
    `aAde`    (将 `Abc` 规约为 `A`)
    `aABe`    (将 `d` 规约为 `B`)
    `S`       (将 `aABe` 规约为 `S`) -> **分析成功！**

**但是，新的问题来了：在每一步，我们怎么知道应该规约哪一部分呢？**
*   在 `abcbde` 中，第一个 `b` 是一个合法的可规约项。
*   在 `aAbcde` 中，`Abc` 是一个合法的可规约项。

这个“在当前这一步，最应该被规约的子串”，有一个专门的名字，叫做**句柄 (Handle)**。

**什么是句柄？**
> **句柄是<u>最右推导</u>的逆过程。** 在一个句型中，句柄是与某个产生式右部匹配的子串，将它规约为该产生式的左部非终结符，可以得到上一步的最右句型。

**简单理解**：句柄就是“**正确的、不会导致我们走入死胡同的**”那个可规约子串。自下而上分析的**全部挑战**，就在于如何**准确地找到句柄**。

---
#### 1.3 终极目标：规范规约 (Canonical Reduction)

一个最完美的自下而上分析过程，就是**规范规约**。它指的是，分析的每一步都是**最右推导的精确逆过程**。

*   **最右推导**: 
<img width="1419" height="886" alt="image" src="https://github.com/user-attachments/assets/7872237d-b4dc-4d08-8474-8462a9dfdf71" />

*   **规范规约**:
  <img width="1413" height="807" alt="image" src="https://github.com/user-attachments/assets/c819d679-970a-4882-91f8-fb277fecad80" />

将待规约句型从左向右入栈，对应其最右推导语法树的最左叶子到最右叶子，一旦发现栈顶有可规约项就是也就是最左的2层子树也就是句柄就规约，也就是将该语法树的这个子树的叶子归约到子树根节点
**寻找句柄的挑战**:
*   我们怎么知道 `abcbde` 的句柄是第一个 `b`，而不是第二个 `b`？
*   我们怎么知道 `aAbcde` 的句柄是 `Abc`，而不是 `b`？

不同的分析方法，提供了不同的寻找句柄的策略：
*   **算符优先分析法**：通过比较运算符之间的优先级来“框定”句柄的边界。
*   **LR 分析法**：通过一个强大的 DFA（状态机）来精确地识别句柄的出现，并决定何时进行规约。这是最通用、最准确的方法。

---
#### 1.4 工作台：符号栈

为了实现“移入-规约”这个过程，并有效地追踪我们已经“拼好”的部件，我们需要一个**符号栈**。

**工作流程**:
1.  **初始状态**: 栈为空，输入指针指向第一个 Token。
2.  **循环**:
    a.  **决策**: 分析器根据当前**栈顶的状态**和**下一个输入 Token**，来决定是“移入”还是“规约”。（决策的依据，就是不同分析方法的核心，比如 LR 分析表）。
    b.  **执行“移入”**: 从输入队列拿一个 Token，压入栈顶。
    c.  **执行“规约”**:
        i.  在栈顶找到句柄（比如 `αβ`）。
        ii. 把它从栈顶弹出。
        iii. 把对应的产生式左部非终结符 `A` 压入栈顶。
3.  **结束**:
    *   **成功**: 当栈里只剩下开始符号 `S`，且输入队列为空时，分析成功。
    *   **失败**: 如果在某个决策点，分析器发现既不能移入，也不能规约，则报告语法错误。

---
### 补充一：短语、直接短语与句柄 (与语法树的关系)

这些概念都是**基于语法树**来定义的，它们描述了语法树中不同“片段”的层次关系。

**我们先来看一棵语法树：**

*   **文法**: `E → E * T | T`, `T → T + F | F`, `F → id`
*   **句子**: `id * id + id`
*   **它的一个最右推导**: `E ⇒ E*T ⇒ E*T+F ⇒ E*T+id ⇒ E*F+id ⇒ E*id+id ⇒ T*id+id ⇒ F*id+id ⇒ id*id+id`

**对应的语法树：**
```
      E
      |
      E -- * -- T
      |       |
      T       T -- + -- F
      |       |       |
      F       F      id
      |       |
      id      id
```

**现在，我们来定义这些概念：**

#### 1. 短语 (Phrase)

*   **定义**: 语法树中的**任一棵子树**，其**所有末端节点 (叶子)** 从左到右连接起来形成的字符串，就是相对于该子树根节点的一个**短语**。
*   **直观理解**: 短语就是句子中一个**语法上可以被看作一个整体**的部分。
*   **例子 (看上面的树)**:
    *   以最顶层的 `E` 为根的子树，它的叶子是 `id * id + id`。所以 `id * id + id` 是 `E` 的一个短语。
    *   以中间的 `T` 为根的子树，它的叶子是 `id + id`。所以 `id + id` 是 `T` 的一个短语。
    *   以最左边的 `F` 为根的子树，它的叶子是 `id`。所以第一个 `id` 是 `F` 的一个短语。

#### 2. 简单短语 (Simple Phrase)

*   **定义**: 如果一棵子树的**高度只有2** (即根节点直接连接所有叶子节点)，那么这棵子树的叶子形成的短语，就叫做**简单短语**。
*   **直观理解**: 简单短语是一个**一步推导**就能得到的短语。它正好对应某个产生式的**右部**。
*   **例子**:
    *   `E → T` 这棵子树（最左边的 `E` 和 `T`），它的叶子是 `T` 的叶子，即 `id`。但它的高度不是2。
    *   `T → F` 这棵子树（最左边的 `T` 和 `F`），叶子是`id`。也不是。
    *   `F → id` 这棵子树，高度是2！所以，`id` 是一个简单短语。
    *   `T → T + F` 这棵子树，它的叶子是 `id + id`。但它的高度超过2了，所以 `id+id` 不是简单短语。

#### 3. 句柄 (Handle)

*   **PPT 的定义**: “**最左简单短语**”。
*   **定义**: 一个句型的**句柄**，是这个句型所对应的语法树中，**最左边的那棵高度为2的子树**的叶子节点串。
*   **直观理解**: 句柄就是当前这一步，**最应该被规约**的那个部分。它对应了**最右推导的逆过程**。
*   **为什么是最左？** 因为我们是从左到右扫描输入的，我们最先遇到的那个可以被一步规约的完整单元，就是我们当前能处理的句柄。
*   **例子**:
    *   对于句型 `id * id + id`，它的语法树中，最左边的、高度为2的子树是 `F → id`。所以，**第一个 `id` 就是句柄**。
    *   规约后，句型变成 `F * id + id`。
    *   对于 `F * id + id`，最左的简单短语是 `F` 本身（来自`T->F`）。规约后得到 `T * id + id`。
    *   ... 这个过程不断进行，每一次都规约“最左简单短语”，就是在模拟最右推导的逆过程。

**总结**：`短语 > 简单短语 > 句柄`。句柄是简单短语中最特殊、最靠左的一个，它是自下而上分析器每一轮的“操作目标”。

---
### 第二讲：算符优先分析 —— 一个简单的“热身”



#### **引言：我们的目标与视角**
在自下而上分析的世界里，我们的核心任务是**找到句柄 (Handle)** 并进行规约。算符优先分析法提供了一种简单直观的策略：**通过比较运算符之间的优先级来“框定”句柄的边界**。为了让这个策略行得通，我们必须在一套非常严格的“游戏规则”下进行。

---
**核心场景：分析句子 `a + b * c`**

*   **正确的语法结构**: `a + (b * c)`
*   **正确的句柄**: 在 `a+b*c` 中，第一个句柄是 `b`，然后是 `c`，然后是 `b*c`...  不，最直观的句柄应该是 `b*c` 这个整体。
*   **我们的目标**: 设计一种机制，能让计算机自动发现 `b*c` 是一个应该被优先“打包”（规约）的整体。

---

#### **1.1 准入许可证：算符文法 (Operator Grammar)**

不是所有的文法都有资格参与“算符优先”这个游戏。只有满足特定条件的**算符文法**才能入场。


**算符优先文法的条件：**
1.  **没有 `A → BC` 这种相邻的非终结符。**
2.  **没有 `A → ε` 产生式。**

**为什么要有这些条件？**
> 为什么如果允许 A → BC，分析器就找不到“路牌”了？为什么只有算符文法才能入场？

我们来做一个思想实验，假设我们**违反**了算符文法的规定。

*   **一个“坏”的文法 (非算符文法)**:
    1.  `E → T | E + T`
    2.  `T → F | T F`  (**违反！** `T` 和 `F` 两个非终结符相邻)
    3.  `F → id`

*   **一个推导过程**: `E ⇒ E+T ⇒ E+TF ⇒ E+Tid ⇒ E+Fid ⇒ E+idid ⇒ ...`
    *   在某个中间句型中，我们可能得到 `...id id...` 这样的结构，其中第一个 `id` 来自 `T`，第二个 `id` 来自 `F`。

**现在，我们来构造优先关系表。**
我们要确定 `id` 和 `id` 之间的关系。算法要求我们去文法里找模式。
*   我们找到了 `T → T F` 这条规则。
*   算法想确定 `LASTVT(T)` 和 `FIRSTVT(F)` 之间的关系。
    *   `LASTVT(T)` 包含 `id`。
    *   `FIRSTVT(F)` 包含 `id`。
*   但是，在 `T` 和 `F` 之间，**没有任何终结符**！我们的构造规则（`...aP...`, `...Pa...`, `...aPb...`）**全都用不上**！
    *   `a<∙b` 的规则是 `...aP...`，`a` 和 `P` 之间没有东西。
    *   `b∙>a` 的规则是 `...Pa...`，`P` 和 `a` 之间没有东西。
*   **结果**: 算法在 `T` 和 `F` 之间找不到任何“路牌”（终结符），因此**无法定义** `LASTVT(T)` 中的终结符和 `FIRSTVT(F)` 中的终结符之间的优先关系。优先关系表 `M[id, id]` 将是一个**空白格**。

**回到分析过程**:
当分析器处理 `...id * id...` 时（假设乘法用 `TF` 表示），栈顶是 `id`，输入是 `id`。分析器去查表 `M[id, id]`，发现是**空的**！它不知道该移入还是规约，程序卡住了。

**结论**:
“**不允许 `A → BC`**” 这个规定，就是为了从根本上杜绝这种“**关系真空**”的出现。它强制要求任意两个非终结符之间必须由一个终结符隔开（`A → B a C`）。这个 `a`，就成了 `B` 的结尾和 `C` 的开头之间的“**关系联络员**”或“**路牌**”，使得优先关系可以被明确地定义出来。

所以，只有算符文法才能保证我们能构造出一张**没有空白格**的、完整的优先关系表。这就是它的“入场券”。

---

#### **1.2 导航路牌：三种优先关系**

算符优先分析器的所有决策，都依赖于比较“栈顶终结符”和“当前输入符”这两种关系。

*   **`a <∙ b` (移入优先)**：`a` 的优先级低于 `b`。意味着一个更高优先级的语法结构以 `b` 开始了。**动作：移入**。
*   **`a ∙> b` (规约优先)**：`a` 的优先级高于 `b`。意味着以 `a` 结尾的一个高优先级语法结构已经完整了（句柄的尾部找到了）。**动作：规约**。
*   **`a ∙= b` (同级优先)**：`a` 和 `b` 是同一个语法结构的一部分，比如括号 `()`。**动作：移入**。

#### **1.3 核心特性：不对称性**

> **虽然有 `t₁ ∙> t₂`，不一定有 `t₂ <∙ t₁`。**

*   **为什么？** 因为 `<∙` 和 `∙>` 回答的是两个**完全不同**的问题。
    *   **`t₂ <∙ t₁` 问的是**：“当我看到 `t₂`，后面又来了 `t₁` 时，我是不是该**开启**一个由 `t₁` 主导的新结构？” (例如 `+` 遇到 `*`)
    *   **`t₁ ∙> t₂` 问的是**：“当我看到 `t₁`，后面又来了 `t₂` 时，是不是标志着我 (`t₁`) 所在的这个结构已经可以**结束**了？” (例如 `*` 遇到 `+`)
*   一个是“**开启**”的判断，一个是“**结束**”的判断。这两个判断的场景和逻辑都不同，所以它们的关系不是简单的数学大小比较，**不是对称的**。


---


#### 2.2 算符优先分析

想象一下，你正在编写一个只能处理简单加减乘除的计算器程序。你的任务是，拿到一个像 `id + id * id` 这样的、没有括号的 Token 序列，然后正确地计算出结果。

你的大脑知道应该“先算乘法，后算加法”。**算符优先分析法，就是把这个直觉“算法化”的一套机制。**

#### **核心思想：用“优先级”确定运算边界**

自下而上分析的核心是找到**句柄 (Handle)** 并进行规约。算符优先分析法认为，一个由运算符和操作数构成的句柄，它的边界一定是由**优先级的变化**来确定的。

*   当优先级**持续升高**时（比如 `+` 后面遇到 `*`），说明我们还在“爬坡”，句柄还没完整，应该继续向后看。
*   当优先级**突然下降**时（比如 `*` 后面遇到 `+`），说明“爬坡”结束了，一个高优先级的“山顶”（句柄）已经形成，是时候把它处理掉了（规约）。

#### **第一步：定义“路况”——三种优先关系**

为了将“优先级变化”这个概念形式化，我们定义了任意两个**终结符**（我们称之为“算符”）`θ₁` 和 `θ₂` 之间的三种关系：

1.  **`θ₁ <∙ θ₂` (移入优先)**
    *   **含义**: `θ₁` 的优先级**低于** `θ₂`。
    *   **比喻**: 遇到了一个**上坡路** `( `。
    *   **决策**: 句柄尚未形成，应该将 `θ₂` **移入 (Shift)** 栈中，继续前进。
    *   **例子**: `... + * ...`  =>  `+ <∙ *`

2.  **`θ₁ ∙> θ₂` (规约优先)**
    *   **含义**: `θ₁` 的优先级**高于** `θ₂`。
    *   **比喻**: 遇到了一个**下坡路** `) `。
    *   **决策**: 以 `θ₁` 结尾的句柄已经在栈顶形成，应该立即进行**规约 (Reduce)**。
    *   **例子**: `... * + ...`  =>  `* ∙> +`

3.  **`θ₁ ∙= θ₂` (同级优先)**
    *   **含义**: `θ₁` 和 `θ₂` 属于同一个句柄的“内部”。
    *   **比喻**: 在一段**平路**上行驶 ` = `。
    *   **决策**: 句柄还未完整，继续**移入**。
    *   **例子**: `( ... )` 或 `if ... then`  =>  `( ∙= )` , `if ∙= then`

#### **第二步：绘制“导航图”——构造算符优先关系表**

为了让分析器能快速查询这些关系，我们需要预先计算出一张二维表。

**前提条件**: 文法必须是**算符文法**（没有 `A→BC` 或 `A→ε`）。

**构造工具**: `FIRSTVT(P)` 和 `LASTVT(P)` 集合。
*   `FIRSTVT(P)`: `P` 能推导出的**第一个终结符**的集合。
*   `LASTVT(P)`: `P` 能推导出的**最后一个终结符**的集合。

**构造规则 (遍历所有产生式)**:
*   **寻找 `<∙` (上坡)**: 找 `...θ₁ P...` 结构，对于 `FIRSTVT(P)` 中的每个 `θ₂`，置 `θ₁ <∙ θ₂`。
*   **寻找 `∙>` (下坡)**: 找 `...P θ₁...` 结构，对于 `LASTVT(P)` 中的每个 `θ₂`，置 `θ₂ ∙> θ₁`。
*   **寻找 `∙=` (平路)**: 找 `...θ₁ θ₂...` 或 `...θ₁ P θ₂...` 结构，置 `θ₁ ∙= θ₂`。

#### **第三步：开始“驾驶”——算符优先分析算法**

现在，我们有了“导航图”（优先表），可以开始分析输入了。

**工作台**:
*   一个**符号栈**，栈底预置一个边界符 `$`。
*   一个**输入队列**，末尾预置一个边界符 `$`。

**算法流程**:

1.  **初始化**: `$` 入栈。
2.  **主循环**:
    a.  设 `k` 是栈顶的第一个终结符，`a` 是当前输入符号。
    b.  查询 `k` 和 `a` 的优先关系 `k ? a`。

    c.  **case `k <∙ a` 或 `k ∙= a`**:  // 上坡或平路
        i.  **移入 (Shift)**: 将 `a` 压入栈中。
        ii. 输入指针后移一位。

    d.  **case `k ∙> a`**: // 下坡，该规约了！
        i.  **寻找句柄**: 从栈顶开始，向栈底扫描，找到**最近的**一个终结符 `j`，使得 `j <∙ k`。
        ii. 句柄就是 `j` 和 `k` 之间的所有内容（包括 `k`，不包括 `j`）。
        iii. **规约 (Reduce)**: 将这个句柄从栈中弹出，然后压入一个**通用的非终结符**（比如 `N`）。
        iv. **注意**: **输入指针保持不动**，因为 `a` 还没有被处理，它将是下一轮比较的对象。

    e.  **case `关系为空` (error)**:
        i.  报告语法错误。

    f.  **case `k = $` 且 `a = $`**:
        i.  **接受 (Accept)**: 分析成功，结束。

#### **第四步：一个完整的例子**

*   **文法**: `E → E+T | T`, `T → T*F | F`, `F → id`
*   **输入**: `id + id * id $`
*   **优先关系 (部分)**: `+ <∙ *`, `* ∙> +`, `+ ∙> $`, `* ∙> $`, `$ <∙ id` ...

**模拟过程**:

| 栈 | 优先关系 | 输入 | 动作 |
| :--- | :--- | :--- | :--- |
| `$` | `$ <∙ id` | `^id + id * id $` | 移入 `id` |
| `$ id` | `id ∙> +` | `  ^+ id * id $` | 规约 `id` -> `N` |
| `$ N` | `$ <∙ +` | `  ^+ id * id $` | 移入 `+` |
| `$ N +` | `+ <∙ id` | `    ^id * id $` | 移入 `id` |
| `$ N + id`| `id ∙> *` | `      ^* id $` | 规约 `id` -> `N` |
| `$ N + N` | `+ <∙ *` | `      ^* id $` | 移入 `*` |
| `$ N + N *`| `* <∙ id` | `        ^id $` | 移入 `id` |
| `$ N+N*id`| `id ∙> $` | `           ^$` | 规约 `id` -> `N` |
| `$ N+N*N` | `* ∙> $` | `           ^$` | 规约 `N*N` -> `N` |
| `$ N + N` | `+ ∙> $` | `           ^$` | 规约 `N+N` -> `N` |
| `$ N` | `$ ∙= $` | `           ^$` | 接受！(这里假设 `$= $` 是接受) |

**注意**: 在实际算法中，栈里会同时有终结符和非终结符。比较时，我们会从栈顶向下找到第一个终结符。


---
#### **1. 素短语 (Prime Phrase)**

*   **定义**: 一个算符文法的句型中的一个子串，如果它至少包含一个终结符，并且它本身的两侧是具有更高优先级的终结符，或者它已经是整个句型的边界，那么这个子串就称为**素短语**。
    *   更形式化的说，对于句型 `...a S b...`，如果 `a <∙ S的第一个终结符` 且 `S的最后一个终结符 ∙> b`，那么`S`就是一个素短语。

*   **直观理解 (用“括号匹配”思想)**:
    > **素短语就是由一对 `<∙` 和 `∙>` 像括号一样“包”起来的、<u>最长</u>的那个符号串。**

*   **例子**:
    *   句子: `$ id + id * id $`
    *   优先关系链: `$ <∙ id ∙> + <∙ id ∙> * <∙ id ∙> $`
    *   我们来找 `<∙ ... ∙>` 这种模式：
        *   `$ <∙ id ∙> +`：`id` 是一个素短语。
        *   `+ <∙ id ∙> *`：`id` 是一个素短语。
        *   `* <∙ id ∙> $`：`id` 是一个素短语。
    *   如果我们已经规约了一部分，比如得到了 `$ N + N * N $`
    *   优先关系链: `$ <∙ + <∙ * ∙> $` (这里忽略了非终结符)
    *   我们找到了 `<∙ * ∙>` 这个模式。在栈里，它对应的是 `N*N`。所以 `N*N` 是一个素短语。

#### **2. 最左素短语 (Leftmost Prime Phrase)**

*   **定义**: 在一个句型中，**最左边的那个素短语**。
*   **核心关系**:
    > **最左素短语，就是算符优先分析中的“句柄”。**

*   **为什么？**
    *   算符优先分析算法的工作流程，就是不断地寻找**优先级最高的区域**并进行规约。
    *   这个“最高优先级”的区域，在符号串上就表现为由 `<∙` 和 `∙>` 包围的结构。
    *   由于我们是从左到右扫描的，我们找到的**第一个**完整的 `<∙ ... ∙>` 结构，自然就是**最左边的那个素短语**。

*   **算法的体现**:
    *   算符优先分析算法中，“**当 `k ∙> a` 时开始在栈中回溯查找最近的 `<∙`**” 这个动作，就是在**定位最左素短语（句柄）的边界**。

**总结**:
*   **素短语**是算符优先分析法能够识别的“语法单元”，是“短语”概念在算符文法中的一种简化替代品。
*   **最左素短语**就是分析器在每一步中要寻找的**句柄**。

---

#### 2.4 优缺点总结

*   **优点**:
    1.  **实现简单**: 算法逻辑直观，核心就是查表和比较，很容易手动实现。
    2.  **效率高**: 分析过程是线性的。
    3.  **擅长处理表达式**: 对于以中缀表示的算术表达式和逻辑表达式，这种方法非常有效。

*   **缺点**:
    1.  **能分析的文法有限**: 必须是算符文法，这排除了很多常见的语法结构。
    2.  **“假装”规约**: 它只能找到句柄的边界，但**无法确定**应该用哪一条产生式进行规约。因此，它**不能**用于构造详细的语法树，通常只能得到一个运算符的执行序列。
    3.  **错误处理能力弱**: 发现错误后，恢复起来比较困难。

---
### **补充三：优先函数 (Precedence Functions)**

我们之前讨论的**优先关系表**，在实现时有几个缺点：
1.  **占用空间大**: 如果有 `n` 个终结符，就需要一个 `n x n` 的二维数组来存储。
2.  **查找效率**：虽然查表很快，但还有提升空间。
3.  **构造复杂**：计算 `FIRSTVT` 和 `LASTVT` 有些繁琐。

**优先函数**提供了一种更优雅、更高效的替代方案。

*   **核心思想**:
    > 我们不存储两两之间的关系，而是为**每一个终结符** `θ` 分别赋予两个**整数值**：
    > *   **`f(θ)`**: 栈内优先函数 (In-Stack Precedence, ISP)
    > *   **`g(θ)`**: 栈外优先函数 (In-Coming Precedence, ICP)
    >
    > 然后，通过比较这两个整数的大小，来**动态地推导出**优先关系。

*   **推导规则**:
    *   如果栈顶终结符是 `θ₁`，当前输入是 `θ₂`：
        *   若 **`f(θ₁) < g(θ₂)`**，则 `θ₁ <∙ θ₂` (移入)。
        *   若 **`f(θ₁) > g(θ₂)`**，则 `θ₁ ∙> θ₂` (规约)。
        *   若 **`f(θ₁) = g(θ₂)`**，则 `θ₁ ∙= θ₂` (移入，通常用于括号)。

*   **`f` 和 `g` 的直观理解**:
    *   `f(θ)` (栈内/左边) 代表了这个运算符作为**一个运算的结尾**时的“坚守能力”。
    *   `g(θ)` (栈外/右边) 代表了这个运算符作为**一个运算的开始**时的“抢占能力”。

*   **一个经典的例子 (加减乘除)**:
    | 符号 θ | `f(θ)` (栈内) | `g(θ)` (栈外) |
    | :--- | :--- | :--- |
    | `+`, `-` | 2 | 1 |
    | `*`, `/` | 4 | 3 |
    | `(` | 0 | 5 |
    | `)` | - | 0 |
    | `id` | 6 | 5 |
    | `$` | 0 | 0 |

*   **我们来验证一下**:
    *   **比较 `+` (栈内) 和 `*` (栈外)**:
        *   `f(+) = 2`, `g(*) = 3`。
        *   `f(+) < g(*)` => `+ <∙ *` (移入)。**正确！**
    *   **比较 `*` (栈内) 和 `+` (栈外)**:
        *   `f(*) = 4`, `g(+) = 1`。
        *   `f(*) > g(+)` => `* ∙> +` (规约)。**正确！**
    *   **比较 `(` (栈内) 和 `id` (栈外)**:
        *   `f(() = 0`, `g(id) = 5`。
        *   `f(() < g(id)` => `( <∙ id` (移入)。**正确！**
    *   **比较 `+` (栈内) 和 `+` (栈外) (处理左结合性)**:
        *   `f(+) = 2`, `g(+) = 1`。
        *   `f(+) > g(+)` => `+ ∙> +` (规约)。这意味着 `a+b+c` 会被解析成 `(a+b)+c`，因为看到第二个 `+` 时，会先规约前面的 `a+b`。


---
#### **优先函数的构造方法**

我们知道，优先函数 `f(θ)` (栈内) 和 `g(θ)` (栈外) 是优先关系表的一种高效实现。但前提是，这样的函数必须**存在**。

**构造方法**：这是一个基于图论思想的算法。

1.  **建立图 (Graph Construction)**:
    *   为**每一个终结符 `θ`** 和**边界符 `$`**，创建**两个节点**: 一个叫 `f_θ`，另一个叫 `g_θ`。
    *   所以，如果有 `n` 个终结符，你将得到 `2 * (n+1)` 个节点。

2.  **根据优先关系添加有向边**:
    *   遍历优先关系表中的**每一个**关系：
        *   如果 **`θ₁ ∙= θ₂`**，则从 `f_θ₁` 向 `g_θ₂` 画一条有向边：`f_θ₁ → g_θ₂`。
        *   如果 **`θ₁ <∙ θ₂`**，则从 `f_θ₁` 向 `g_θ₂` 画一条有向边：`f_θ₁ → g_θ₂`。
        *   如果 **`θ₁ ∙> θ₂`**，则从 **`g_θ₂`** 向 **`f_θ₁`** 画一条有向边：`g_θ₂ → f_θ₁`。(注意方向！)

3.  **检查环路 (Cycle Detection)**:
    *   检查这个构造出来的有向图，**是否存在任何环路**。
    *   **如果存在环路**，例如 `f_a → g_b → f_c → f_a`，那么**优先函数不存在**，该方法失败。
    *   **如果不存在环路**（即这是一个**有向无环图 DAG**），那么优先函数**一定存在**。

4.  **计算函数值 (Topological Sort Idea)**:
    *   **为每个节点 `N`，计算它的值 `Value(N)`，该值等于从 `N` 出发的最长路径的长度。**
    *   你可以从入度为0的节点开始，使用类似拓扑排序的算法来计算。
    *   一个简单的计算方法是：
        *   将所有节点的初始值设为 0。
        *   反复遍历所有的边 `U → V`，更新 `Value(V) = max(Value(V), Value(U) + 1)`，直到没有更新为止。
    *   最终，**`f(θ) = Value(f_θ)`**，**`g(θ) = Value(g_θ)`**。

**为什么这个方法有效？**
*   我们要求 `f(θ₁) < g(θ₂)` 等价于 `θ₁ <∙ θ₂`。
*   在图中，`θ₁ <∙ θ₂` 对应一条边 `f_θ₁ → g_θ₂`。
*   如果我们将节点的值定义为最长路径长度，那么 `Value(f_θ₁) < Value(g_θ₂)` 这个关系并不一定成立。但 `Value(f_θ₁) + 1 ≤ Value(g_θ₂)` 是成立的。
*   这个构造方法保证了，只要优先函数存在，就能找到一组整数 `f` 和 `g` 满足 `f(a) > g(b) <=> a ∙> b` 等关系。虽然不一定是严格的小于，但大小关系是一致的。

**结论**：这是一个系统性的算法，但在手动做题时通常比较繁琐。手动构造优先函数，更多的是靠观察和凑数，比如经典的 `+` (f=2,g=1) 和 `*` (f=4,g=3) 的例子。

---
#### 2.5 算符优先分析法的出错处理

算符优先分析法的错误检测能力比较简单：
> **当栈顶终结符 `k` 和当前输入 `a` 之间的优先关系在表中是<u>空白</u>时，就检测到了一个错误。**

但是，它的错误恢复能力比较弱，因为它“看不见”非终结符，很难判断语法结构的整体情况。

**常见的出错处理方法：**

##### **1. 恐慌模式 (Panic Mode) 的简化版**

这是最简单、最常用的方法。

*   **策略**: 寻找一个具有“**定界**”意义的符号，然后跳过中间的所有内容。
*   **具体操作**:
    1.  当检测到错误时（比如 `M[k, a]` 为空），报告错误。
    2.  **扫描输入流**，不断地**丢弃**输入符号，直到遇到一个**高可信度的“同步符号”**，比如**分号 `;`** 或者**右括号 `)`**。
    3.  **同时，从栈中不断弹出符号**，直到栈顶的符号与刚刚找到的同步符号能够形成一个**合法的优先关系**（比如 `k <∙ ;` 或 `k ∙= )`）。
    4.  从这个点开始，恢复正常的分析过程。

*   **优点**: 实现简单。
*   **缺点**: 可能会丢弃大量的有效代码，导致连锁错误。

##### **2. 基于优先关系的局部修正**

这种方法更智能一些，它尝试对错误进行小范围的“修复”。

*   **策略**: 当 `M[k, a]` 为空时，分析器假定这里可能缺少了某个运算符，或者多了一个操作数等等。它会根据 `k` 和 `a` 的**优先函数值**来“猜测”应该是什么关系。

*   **几种可能的修复场景**:
    1.  **错误类型：`...id id...` (操作数相邻)**
        *   **检测**: `M[id, id]` 可能是空的。
        *   **修复**: 假设中间缺少了一个运算符，比如 `+`。在输入流中**插入**一个 `+`，然后继续分析。
    2.  **错误类型：`... + * ...` (运算符相邻)**
        *   **检测**: `M[+, *]` 可能是空的。
        *   **修复**: 假设中间缺少了一个操作数 `id`。**压入**一个代表 `id` 的符号到栈中，然后继续分析。
    3.  **错误类型：`... + ) ...`**
        *   **检测**: `M[+, )]` 关系是 `+ ∙> )`，分析器会尝试规约 `+` 左边的内容。但如果左边内容不合法（比如只有一个 `(`)，规约会失败。
        *   **修复**: 假设 `(` 和 `+` 之间缺少操作数，或者 `+` 是多余的。可以尝试**删除** `+` 或者**弹出**栈里的 `(`。

*   **优点**: 能够提供更具体的错误修复建议，IDE 中的一些简单语法纠错功能就基于类似的思想。
*   **缺点**: 实现非常复杂，需要为每一种可能的“空白格”都预先定义好修复策略，容易引入新的错误。

**总结**:
算符优先分析的错误处理，不像 LL(1) 或 LR 那样有 `FOLLOW` 集等系统性的工具可以依赖。它的错误恢复更多是基于一些启发式的、经验性的规则，其中“恐慌模式”是最基本和可靠的保底策略。


---
### **第三讲：LR 分析法入门**

#### **引言：为什么需要 LR 分析法？**

到目前为止，我们已经探索了自下而上分析的“世界地图”，并了解了两个关键地点：

1.  **理论的“圣杯”：规范规约 (Canonical Reduction)**
    *   **它是什么？** 一种**最理想、最完美**的自下而上分析过程，是“最右推导”的精确逆过程。
    *   **它的优点？** 它能处理**最大范围**的上下文无关文法，并且能构造出唯一的、正确的语法树。
    *   **它的问题？** 它只是一个**理论目标**。它告诉我们“应该做什么”（在每一步都准确找到句柄并规约），但**没有告诉我们“具体要怎么做”**。如何仅凭从左到右的扫描，就能准确无误地识别出那个“最右推decin的逆过程”中的句柄？这是一个巨大的挑战。

2.  **一个“聪明的捷径”：算符优先分析法 (Operator-Precedence Parsing)**
    *   **它是什么？** 一种试图解决“如何找句柄”问题的**简化方案**。
    *   **它的策略？** 放弃理解完整的语法结构，只通过比较相邻**终结符**的优先级，来“框定”出**最左素短语**作为句柄的近似替代品。
    *   **它的优点？** 实现简单，对于表达式类文法很有效。
    *   **它的致命缺陷？**
        *   **文法限制太强**：必须是算符文法，连 `E → T E'` 这种相邻非终结符的规则都处理不了。
        *   **规约“盲目”**：它只知道句柄的边界，但**不知道**应该用 `E→T` 还是 `T→F` 来规约。因此，它无法构建精确的语法树，能力非常有限。

**三者的关系，就像寻找宝藏：**

> **规范规约** 告诉我们：“宝藏（句柄）确实存在，而且每一步只有一个是真的。”
>
> **算符优先分析** 提供了一张“**简陋的藏宝图**”，它能大致圈出宝藏可能在的区域，但地图不清晰，而且很多地方都画不了。
>
> **LR 分析法** 则提供了一台“**精密的 GPS 导航仪**”。它能严格地、精确地、一步不差地引导我们找到每一个真正的宝藏（句柄），并且告诉我们这个宝藏的“型号”（具体是哪个产生式）。

**所以，LR 分析法的历史使命就是：**
> **为“规范规约”这个完美的理论目标，提供一个通用的、强大的、可实现的算法。**

它结合了两者的优点：既有规范规约的**强大能力和准确性**，又有像算符优先分析那样的**机械化、基于查表**的实现方式。

---
#### **3.1 LR 分析器：一台通用的“移入-规约”状态机**

现在，我们来揭开这台“精密 GPS 导航仪”的内部构造。

一个 LR 分析器，无论它具体是 SLR(1), LALR(1) 还是 LR(1)，它的**物理结构**和**工作流程**都是完全一样的。

##### **核心组件 (The Hardware)**

1.  **输入缓冲区 (Input)**: 存放 Token 序列，以 `$` 结尾。
2.  **分析栈 (Stack)**: 这是 LR 分析的“**短期记忆**”。与 LL 分析不同，LR 的栈里存放的不是文法符号，而是**状态编号 (State Numbers)**。栈顶的状态代表了分析器对**已经读过的所有输入**的全部理解。
3.  **总控程序 (Driver)**: 一个**固定的、与文法无关**的算法。它的工作就是循环执行“看-查-动”的流程。
4.  **LR 分析表 (The Software/Map)**: 这是 LR 分析器的“**大脑**”，包含了所有的决策逻辑。它由两部分构成：
    *   **ACTION 表**: 指示“看到**终结符**时该做什么”。
    *   **GOTO 表**: 指示“规约出**非终结符**后该去哪里”。

##### **工作循环 (The "See-LookUp-Act" Loop)**

总控程序的逻辑极其简单：

> **`while (true)`**:
> 1.  **看 (See)**:
>     *   看**栈顶的状态**，记为 `s`。
>     *   看**当前的输入符号**，记为 `a`。
> 2.  **查 (Look Up)**:
>     *   在 **ACTION 表**中查询 `ACTION[s, a]`。
> 3.  **动 (Act)**:
>     *   根据查询结果，执行四种动作之一。

##### **四种动作 (The Four Actions)**

1.  **移入 (Shift s')**: `ACTION[s, a] = shift s'`
    *   **动作**: 将新状态 `s'` 压入栈顶，并将输入指针后移一位。
    *   **含义**: 当前的输入 `a` 是句柄的一部分，但句柄还不完整。我们需要继续读入更多符号。

2.  **规约 (Reduce r)**: `ACTION[s, a] = reduce r` (r 是产生式 `A → β` 的编号)
    *   **动作**:
        a.  从栈中弹出 `|β|` (β的长度) 个状态。
        b.  此时，新的栈顶状态是 `s'`。
        c.  查询 **GOTO 表**: `GOTO[s', A]`，得到新状态 `s_new`。
        d.  将 `s_new` 压入栈顶。
    *   **含义**: 在状态 `s` 时，我们已经看完了整个句柄 `β`。现在执行规约，并根据 GOTO 表跳转到识别出 `A` 之后的新状态。

3.  **接受 (Accept)**: `ACTION[s, $] = accept`
    *   **动作**: 宣布分析成功。
    *   **含义**: 整个输入已经被成功规约为开始符号。

4.  **报错 (Error)**: `ACTION[s, a]` 是空白格
    *   **动作**: 调用错误恢复程序。
    *   **含义**: 在当前状态 `s` 下，绝不应该看到输入 `a`。

---

#### 3.2 LR(0) 项目与状态机构造 

**我们的目标**: 构造出 LR 分析器的“大脑”——**ACTION 表**和 **GOTO 表**。

**核心思想**:
> **LR 分析器的每一个“状态”，都对应着一个“项目集 (Set of Items)”。**
>**LR 分析法的全部目的，就是通过预先计算，为这个“瞎子”分析器，构建一个强大的“记忆和预测系统”。**
> 这个系统，就是我们构造的**项目集 DFA**。
> 这个项目集，精确地描述了分析器在识别过程中的**所有可能性**，即“我们目前可能正在匹配哪条规则，并且匹配到什么进度了”。
---


**项目集 DFA 的真正含义：编码了上下文的“状态”**


> **DFA 中的一个状态 `I` (项目集)，就是分析器在某个时刻的“记忆快照”。它精确地编码了到目前为止，我们已经识别出的语法片段（活前缀），能够用来推导出哪些更大的语法结构。**

**一个比喻：拼图**

*   **文法**: 是一整盒拼图的所有“小目标”（比如“拼出蓝色天空”、“拼出红色屋顶”）。
*   **输入**: 是一堆散乱的拼图碎片。
*   **分析栈**: 是你已经拼好的一部分。
*   **一个状态 (项目集)**: 是对你已拼好部分的**解读**。

**场景**: 你已经拼好了一块蓝色的区域（栈里的内容），现在你拿起一块新的蓝色碎片（下一个输入）。

*   **这个状态 `I` (项目集) 就在告诉你**:
    *   “你手头的这块蓝色区域，可能是‘天空’的一部分 (`Sky → Blue∙...`)。”
    *   “也可能是‘大海’的一部分 (`Sea → Blue∙...`)。”
    *   “如果你接下来拼上一块云朵，我们就会进入‘确定是天空’的状态 (`goto(I, cloud) = J_sky`)。”
    *   “如果你接下来拼上一朵浪花，我们就会进入‘确定是大海’的状态 (`goto(I, wave) = J_sea`)。”

**所以，DFA 的每一条路径，都代表了对输入的一种特定语法结构的识别过程。**

---

##### **3.2.1 核心绘图工具：LR(0) 项目 (Item)**

*   **什么是“项目”？**
    *   一个 LR(0) 项目，就是一个在产生式右部的**某个位置**加了一个“**进度点 `∙`**”的产生式。
    *   **例子**: 对于产生式 `A → XYZ`，我们可以得到四个不同的项目：
        *   `A → ∙XYZ` : 我们正**准备**识别一个 `A`，还未开始。
        *   `A → X∙YZ` : 我们已经成功识别了一个 `X`，**接下来期望**看到一个 `Y`。
        *   `A → XY∙Z` : 我们已经成功识别了 `XY`，**接下来期望**看到一个 `Z`。
        *   `A → XYZ∙` : 我们已经成功识别了完整的 `XYZ`，现在是时候**进行规约**了。

*   **项目的含义**:
    *   一个项目 `[A → α∙β]` 包含了两种信息：
        1.  我们当前可能正在匹配的产生式是 `A → αβ`。
        2.  我们已经成功识别了 `α` 部分，接下来期望识别 `β` 部分。

---

##### **3.2.2 关键操作一：闭包 (Closure) 运算**

*   **问题**: 仅有 `A → ∙XYZ` 这个项目是不够的。如果我们要开始识别 `XYZ`，那么我们首先需要识别 `X`。如果 `X` 本身又是一个非终结符（比如 `X → p|q`），那么我们就**也**进入了“准备识别 `p`”和“准备识别 `q`”的状态。
*   **闭包运算 `CLOSURE(I)` 的作用**:
    > **从一个已有的项目集 `I` 出发，不断地“丰富”和“扩展”它，直到所有“待办事项”都被明确列出为止。**

*   **算法**:
    1.  将 `I` 中的所有项目加入结果集 `J`。
    2.  **重复**以下步骤，直到 `J` 不再增大：
        *   在 `J` 中寻找一个形如 `[A → α∙Bβ]` 的项目 (进度点 `∙` 后面是一个**非终结符 `B`**)。
        *   找到文法中 `B` 的所有产生式 `B → γ₁ | γ₂ | ...`。
        *   将这些产生式对应的**初始项目** `[B → ∙γ₁]`, `[B → ∙γ₂]`, ... 全部加入到 `J` 中（如果它们不在 `J` 里的话）。

*   **直观理解**:
    *   闭包运算就是在回答：“如果我的光标 `∙` 后面遇到了一个非终结符 `B`，那么我实际上也需要**同时准备好**开始识别 `B` 的所有可能性。”

*   **为什么要做闭包 (Closure)？—— 准备好所有“下一步可能性”**
   *   **原因**: 自上而下和自下而上在这里交汇了！
   *   **场景**: 你当前的项目是 `[A → α∙Bβ]`。从自下而上的角度，你已经识别了 `α`。但为了能最终识别出 `A`，你接下来**必须**识别出一个 `B`。
   *   **如何识别 `B`？** 你必须**从头开始**，尝试 `B` 的所有产生式，比如 `B → γ₁ | γ₂`。
   *   **闭包的本质**: 这是一个“**自上而下的预测**”步骤。它在说：“为了完成我自下而上的大目标 `A`，我需要启动一个自上而下的子任务，去识别 `B`。因此，我必须把 `[B → ∙γ₁]` 和 `[B → ∙γ₂]` 也加入到我当前的可能性列表中。”
   *   **不做闭包会怎样？** 你的状态信息就不完整。你只知道你要找 `B`，但不知道 `B` 长什么样，也不知道该如何开始识别它。

---

##### **3.2.3 关键操作二：goto(I, X) 函数**

*   **问题**: 如果我们当前处于状态 `I`（一个项目集），并且成功地识别（移入）了一个符号 `X`，那么我们应该**转移到哪个新状态**？
*   **`goto(I, X)` 函数的作用**:
    > **计算出在状态 `I` 识别了符号 `X` 之后，所到达的那个新的项目集（新状态）。**

*   **算法**:
    1.  创建一个空的项目集 `J`。
    2.  对于 `I` 中的**每一个**形如 `[A → α∙Xβ]` 的项目（进度点 `∙` 后面正好是 `X`）：
        *   将“**进度点后移一位**”得到的新项目 `[A → αX∙β]` 加入到 `J` 中。
    3.  **最终结果**: `goto(I, X) = CLOSURE(J)`。
        *   **关键**：在移动了所有相关的进度点之后，得到的新集合可能又需要被“丰富和扩展”，所以我们必须对这个新集合**再做一次闭包运算**。
*   **2. 为什么要做 goto？—— 在识别路径上“前进一步”**

   *   **原因**: 这是状态机最基本的**状态转移**功能。
   *   **场景**: 你当前在状态 `I`，并且成功地识别（移入）了一个符号 `X`。
   *   **goto 的本质**: 它在回答：“基于我们之前的所有可能性（状态 `I`），在成功识别了一个 `X` 之后，我们的新可能性集合（新状态 `J`）是什么？”
   *   **`goto(I, X)` 的计算过程，就是在模拟这个“前进一步”**:
       1.  它先把 `I` 中所有“正在等待 `X`”的项目（`[A → α∙Xβ]`）拿出来。
       2.  把它们的进度点 `∙` 跨过 `X`，变成 `[A → αX∙β]`。这代表“我们刚刚成功识别了 `X`”。
       3.  然后，对这个新集合再做一次**闭包**。因为进度点 `∙` 移动到了 `β` 的前面，如果 `β` 以非终结符 `C` 开头，我们又需要启动一个新的“自上而下”的子任务去识别 `C`。
   *   **不做 goto 会怎样？** 你就无法构建状态之间的转移关系，整个 DFA 地图就画不出来。
---

##### **3.2.4 构造 LR(0) 项目集族 (状态集合)**

现在我们有了两个核心工具，就可以开始绘制整张“地图”了。这个地图的官方名称叫“**LR(0) 项目集规范族 (Canonical Collection)**”。

**算法**:
1.  **增广文法 (Augmented Grammar)**: 在开始前，为原始文法增加一条新的产生式 `S' → S`，其中 `S'` 是新的开始符号。
    *   **为什么？** 这为整个分析过程提供了一个唯一的“起点”和唯一的“终点”（当规约到 `S'` 时，分析就成功了）。
2.  **创建初始状态 `I₀`**:
    *   `I₀ = CLOSURE({[S' → ∙S]})`。
3.  **创建状态集合 `C`**:
    *   `C = {I₀}`。同时创建一个“待处理列表”，放入 `I₀`。
4.  **循环扩展**:
    *   只要“待处理列表”不为空：
        *   从中取出一个项目集 `I`。
        *   对于文法中的**每一个**符号 `X`（包括终结符和非终结符）：
            *   计算 `J = goto(I, X)`。
            *   如果 `J` 非空，并且 `J` 不在 `C` 中，就把 `J` 加入 `C` 和“待处理列表”。
            *   记录下 `I` 经过 `X` 可以到达 `J`。

**这个过程，本质上就是在构造一个** DFA (确定有限自动机)！**
*   **DFA 的状态**: 就是我们构造出的每一个项目集 `Iᵢ`。
*   **DFA 的转换**: 就是 `goto` 函数定义的路径 `Iᵢ --X--> Iⱼ`。
*   这个 DFA 有一个非常重要的名字：**识别文法活前缀的 DFA (DFA for Viable Prefixes)**。“活前缀”指的是在规约过程中，栈里可能出现的任何前缀。

---



### **3.3 SLR(1) 分析 —— 引入 FOLLOW 集**

#### **3.3.1 构造 LR(0) 分析表：一个“天真”的尝试**

LR(0) 的“0”意味着，它在做决策时，**完全不向后看 (0 Token Lookahead)**。它仅凭当前所在的状态，就试图做出决定。

**构造 ACTION 表和 GOTO 表的算法：**

1.  首先，使用我们上一讲的方法，构造出文法的 **LR(0) 项目集规范族** `{I₀, I₁, ..., Iₙ}` 和 **`goto` 函数**。
2.  **GOTO 表的填写**：
    *   这一步非常直接。如果 `goto(Iᵢ, A) = Iⱼ` (A是非终结符)，那么就在 `GOTO[i, A]` 处填入 `j`。

3.  **ACTION 表的填写 (核心规则)**：
    *   遍历每一个项目集 `Iᵢ`：
        a.  **处理移入 (Shift)**：
            *   如果在 `Iᵢ` 中有一个项目 `[A → α∙aβ]` ( `∙` 后面是**终结符 `a`**)，并且 `goto(Iᵢ, a) = Iⱼ`。
            *   那么，在 `ACTION[i, a]` 处填入 **`shift j`** (或 `sj`)。

        b.  **处理规约 (Reduce)**：
            *   如果在 `Iᵢ` 中有一个**规约项目** `[A → β∙]` ( `∙` 在最末尾，且 `A` 不是增广开始符号 `S'`)。
            *   那么，**对于<u>所有</u>的终结符 `t`** (包括 `$`)，都在 `ACTION[i, t]` 处填入 **`reduce A → β`** (或 `r_k`，k是产生式编号)。
            *   **这就是 LR(0) 最“天真”的地方！** 它不管下一个输入是什么，只要看到一个规约项目，就想进行规约。

        c.  **处理接受 (Accept)**：
            *   如果在 `Iᵢ` 中有项目 `[S' → S∙]` (增广文法的规约项目)。
            *   那么，在 `ACTION[i, $]` 处填入 **`accept`**。

#### **3.3.2 LR(0) 的先天不足：冲突 (Conflict)**

当我们按照上面“天真”的 LR(0) 规则去填表时，很快就会发现问题：**同一个单元格 `ACTION[i, a]`，可能会被填入多个不同的动作！** 这就是**冲突**。

**冲突的两种类型：**

1.  **移入-规约冲突 (Shift-Reduce Conflict)**:
    *   **原因**: 表格的同一个单元格，既要填一个 **`shift`** 动作，又要填一个 **`reduce`** 动作。
    *   **例子**: 在项目集 `Iᵢ` 中，**同时存在**:
        *   `[A → α∙aβ]` (要求在看到 `a` 时 `shift`)
        *   `[B → γ∙]` (要求在看到**任何**符号时都 `reduce`)
    *   **分析器的困惑**: 当我处于状态 `i`，看到输入 `a` 时，我到底是应该移入 `a`，期待构成一个更长的 `αaβ` 呢？还是应该立刻将 `γ` 规约为 `B` 呢？

2.  **规约-规约冲突 (Reduce-Reduce Conflict)**:
    *   **原因**: 表格的同一个单元格，要填入**两个或更多个不同**的 **`reduce`** 动作。
    *   **例子**: 在项目集 `Iᵢ` 中，**同时存在**:
        *   `[A → α∙]` (要求 `reduce A → α`)
        *   `[B → β∙]` (要求 `reduce B → β`)
    *   **分析器的困惑**: 当我处于状态 `i` 时，我应该把栈顶的东西看作是 `α` 并规约为 `A` 呢？还是应该看作是 `β` 并规约为 `B` 呢？

**只要一个文法在构造 LR(0) 分析表时出现了任何冲突，它就不是一个 LR(0) 文法。** 事实上，只有非常一小部分简单的文法是 LR(0) 的。

---
#### **3.3.3 SLR(1) 的解决方案：引入 FOLLOW 集**

SLR(1) 的全称是 **Simple LR(1)**。它的“Simple”之处在于，它使用了与 LR(0) **完全相同的项目集族和 DFA**，但它在**填表**时，做了一个简单而聪明的改进。

**SLR(1) 的核心思想**:
> **LR(0) 的规约动作太“暴力”了！** 它不管三七二十一，看到规约项目就想对所有输入都进行规约。
>
> **一个更聪明的做法是**：只有当**下一个输入符号 `a`**，确实是一个可以**合法地跟在**非终结符 `A` 后面的符号时，我们才应该执行 `A → β` 这个规约动作。
>
> 哪个集合告诉我们 `A` 后面可以合法地跟什么？—— **FOLLOW(A) 集！**

**SLR(1) 分析表的构造算法**：

1.  构造文法的 **LR(0) 项目集规范族** `{I₀, I₁, ..., Iₙ}`。(这一步和 LR(0) **完全一样**)
2.  计算文法中**所有非终结符的 FOLLOW 集**。
3.  **ACTION 表的填写**:
    *   **移入 (Shift)**: **规则和 LR(0) 完全一样**。
        *   `[A → α∙aβ]` in `Iᵢ` and `goto(Iᵢ, a) = Iⱼ` => `ACTION[i, a] = shift j`
    *   **规约 (Reduce)**: **【这里是唯一的区别！】**
        *   `[A → β∙]` in `Iᵢ` (`A ≠ S'`)
        *   **对于 `FOLLOW(A)` 中的<u>每一个</u>终结符 `a`**，在 `ACTION[i, a]` 处填入 **`reduce A → β`**。
    *   **接受 (Accept)**: **规则和 LR(0) 完全一样**。
        *   `[S' → S∙]` in `Iᵢ` => `ACTION[i, $] = accept`
4.  **GOTO 表的填写**: **规则和 LR(0) 完全一样**。

**SLR(1) 如何解决冲突？**
*   通过只在 `FOLLOW(A)` 对应的列填入 `reduce` 动作，SLR(1) 极大地**减少了** `reduce` 动作的填入范围。
*   这使得很多原来在 LR(0) 中会产生冲突的单元格，现在可能只有一个 `shift` 动作，或者干脆是空的，从而**消解了冲突**。

**如果一个文法在构造 SLR(1) 分析表时，没有产生任何冲突，那么它就是一个 SLR(1) 文法。** SLR(1) 能处理的文法范围远大于 LR(0)，大多数无二义性的表达式文法都是 SLR(1) 的。

---
