

---
### 小知识补充
#### 第一部分：句子 (Sentence) vs. 句型 (Sentential Form)

我们先来严格地区分这两个概念。

*   **句子 (Sentence)**:
    *   **定义**：从文法的**开始符号 `S`** 出发，经过一步或多步**推导**，最终得到的**只包含终结符**的字符串。
    *   **直观理解**：一个“句子”就是这个语言中一个**完整、合法、可以被用户写出来**的程序或语句。
    *   **例子**: 对于算术表达式文法，`id * id + id` 是一个句子。

*   **句型 (Sentential Form)**:
    *   **定义**：从文法的**开始符号 `S`** 出发，经过一步或多步**推导**，得到的**可以包含终结符和非终-结符**的字符串。
    *   **直观理解**：一个“句型”是推导过程中的一个“**中间快照**”或“**半成品**”。
    *   **例子**: 在推导 `id * id` 的过程中，我们可能会经过 `E ⇒ T ⇒ T * F ⇒ T * id`。这里的 `E`, `T`, `T * F`, `T * id` **都是句型**。

**两者的关系**：
> **所有的“句子”，都是“句型”的一种特殊情况。** 但“句型”不一定是“句子”。

---

#### 第二部分：如何证明一个字符串是该文法的句型？

> **“能用最左或最右推导得出的句子就是文法的一个句型吗？”**

**你的这句话基本正确，但需要更精确一点：**

> **只要一个字符串 `α` 能够从开始符号 `S` 通过<u>任意一种</u>合法的推导方式（不一定是最左或最右，也可以是混合的）得到，那么 `α` 就是该文法的一个句型。**

所以，要证明字符串 `α` 是文法 `G` 的一个句型，你只需要做一件事：

**给出一个从开始符号 `S` 到 `α` 的完整推导序列。**

#### **做题步骤：**

1.  **确定目标**: 你要证明的目标字符串是 `α`。
2.  **寻找路径 (逆向思维)**：
    *   从 `α` **倒着往回看**，寻找 `α` 中有没有某个子串，正好是某个产生式的**右部**。
    *   如果有，尝试用该产生式的**左部**去替换它，得到一个“更简单”的句型 `α'`。这个过程就是“**规约**”。
    *   对 `α'` 重复这个过程，直到你最终能规约到开始符号 `S`。
3.  **书写证明 (正向推导)**：
    *   把你刚刚“倒着找”的路径，**反过来写一遍**，就成了一个从 `S` 到 `α` 的**正向推导**过程。
    *   在每一步推导 `⇒` 旁边，最好注明你用的是哪一条产生式规则。

#### **一个具体的例子**

*   **文法 G**:
    1.  `E → E + T`
    2.  `E → T`
    3.  `T → T * F`
    4.  `T → F`
    5.  `F → (E)`
    6.  `F → id`

*   **题目**: 证明 `T * id + T` 是文法 G 的一个句型。

**1. 思考过程 (倒着规约)**:
*   目标: `T * id + T`
*   看到 `id`，它可以由 `F → id` 规约而来。我们试试： `T * F + T`。
*   看到 `T * F`，它可以由 `T → T * F` 规约而来。我们试试： `T + T`。
*   看到 `T + T`... 文法里没有 `E → T + T`，只有 `E → E + T`。
*   **这条路好像走不通。我们换一条路。**

*   目标: `T * id + T`
*   我们从右边看，`T` 可以由 `E → T` 规约而来。试试：`T * id + E`。
*   `id` 可以由 `F → id` 规约而来。试试：`T * F + E`。
*   `T * F` 可以由 `T → T * F` 规约而来。试试：`T + E`。
*   `T` 可以由 `E → T` 规约而来。试试：`E + E`。
*   `E + E`... 还是走不通。

*   **再换一条路！** 我们要找**最右推导**的逆过程。
*   目标: `T * id + T`
*   句柄是什么？可能是 `id`。规约 `F → id` => `T * F + T`。
*   新目标: `T * F + T`。句柄是什么？可能是 `T`。规约 `E → T` => `T * F + E`。
*   新目标: `T * F + E`。句柄是什么？可能是 `T*F`。规约 `T → T*F` => `T + E`。
*   新目标: `T + E`。句-柄是什么？可能是 `T`。规约 `E → T` => `E + E`。
*   **又卡住了！**

**这说明，有时候寻找推导路径并不容易。让我们尝试从 `S` (这里是`E`) 正向推导。**

**2. 书写证明 (正向推导)**

*   **目标**: `T * id + T`
*   **开始**: `E`
*   我们看到目标里有 `+`，所以第一步很可能要用 `E → E + T`。
    `E ⇒ E + T`  (使用规则 `E → E + T`)
*   现在我们需要把左边的 `E` 变成 `T * id`。
    `⇒ T + T`    (使用规则 `E → T`)
    `⇒ T * F + T` (使用规则 `T → T * F`)
    `⇒ T * id + T` (使用规则 `F → id`)

*   **找到了！** 我们成功地找到了一个从 `E` 到 `T * id + T` 的推导序列。

**最终的证明过程就是：**
> **证明**:
>
> `E ⇒ E + T` (依据 `E → E + T`)
>
> `⇒ T + T` (依据 `E → T`)
>
> `⇒ T * F + T` (依据 `T → T * F`)
>
> `⇒ T * id + T` (依据 `F → id`)
>
> 因为存在一个从开始符号 `E` 到 `T * id + T` 的推导，所以 `T * id + T` 是该文法的一个句型。

---

---

### 第一讲：自下而上分析的核心思想 —— “搭积木”

#### 1.1 核心动作：移入-规约 (Shift-Reduce)

自下而上分析器的工作过程，可以用一个非常简单的循环来描述，这个循环只包含两种基本动作：

1.  **移入 (Shift)**：
    *   **动作**：将输入队列的**第一个** Token，移动到**分析栈**的顶部。
    *   **比喻**：从零件盒里，拿一个最基本的乐高积木，放到你的工作台上。

2.  **规约 (Reduce)**：
    *   **动作**：当分析栈顶部的**一串符号**，正好匹配了某个产生式规则的**右部**时，就将这串符号从栈中**弹出**，然后将该规则的**左部非终结符**压入栈中。
    *   **比喻**：你发现工作台上的几块积木（比如：轮胎、轮毂、车轴），正好可以拼成一个“车轮”部件。于是你把这些零散积木拿走，换上一个已经组装好的“车轮”部件。你完成了一次**抽象**。

**整个分析过程**，就是在这两种动作之间不断抉择，直到最终栈里只剩下开始符号 `S`，并且输入也被耗尽，此时分析成功。

---
#### 1.2 核心概念：规约 (Reduction)

**规约，就是推导的“逆过程”。**

*   **推导 (Derivation)**：`E ⇒ E + T` (把 `E` 展开成 `E+T`)
*   **规约 (Reduction)**：`E + T ⇒ E` (把 `E+T` 归结为 `E`)

**自下而上分析，本质上就是一个不断寻找“可规约子串”并进行规约的过程。**

**例子**:
*   **文法**: `S → aABe`, `A → Abc | b`, `B → d`
*   **输入**: `abcbde`
*   **一个可能的规约序列**:
    `abcbde`
    `aAbcde`  (将 `b` 规约为 `A`)
    `aAde`    (将 `Abc` 规约为 `A`)
    `aABe`    (将 `d` 规约为 `B`)
    `S`       (将 `aABe` 规约为 `S`) -> **分析成功！**

**但是，新的问题来了：在每一步，我们怎么知道应该规约哪一部分呢？**
*   在 `abcbde` 中，第一个 `b` 是一个合法的可规约项。
*   在 `aAbcde` 中，`Abc` 是一个合法的可规约项。

这个“在当前这一步，最应该被规约的子串”，有一个专门的名字，叫做**句柄 (Handle)**。

**什么是句柄？**
> **句柄是<u>最右推导</u>的逆过程。** 在一个句型中，句柄是与某个产生式右部匹配的子串，将它规约为该产生式的左部非终结符，可以得到上一步的最右句型。

**简单理解**：句柄就是“**正确的、不会导致我们走入死胡同的**”那个可规约子串。自下而上分析的**全部挑战**，就在于如何**准确地找到句柄**。

---
#### 1.3 终极目标：规范规约 (Canonical Reduction)

一个最完美的自下而上分析过程，就是**规范规约**。它指的是，分析的每一步都是**最右推导的精确逆过程**。

*   **最右推导**: 
<img width="1419" height="886" alt="image" src="https://github.com/user-attachments/assets/7872237d-b4dc-4d08-8474-8462a9dfdf71" />

*   **规范规约**:
  <img width="1413" height="807" alt="image" src="https://github.com/user-attachments/assets/c819d679-970a-4882-91f8-fb277fecad80" />

将待规约句型从左向右入栈，对应其最右推导语法树的最左叶子到最右叶子，一旦发现栈顶有可规约项就是也就是最左的2层子树也就是句柄就规约，也就是将该语法树的这个子树的叶子归约到子树根节点
**寻找句柄的挑战**:
*   我们怎么知道 `abcbde` 的句柄是第一个 `b`，而不是第二个 `b`？
*   我们怎么知道 `aAbcde` 的句柄是 `Abc`，而不是 `b`？

不同的分析方法，提供了不同的寻找句柄的策略：
*   **算符优先分析法**：通过比较运算符之间的优先级来“框定”句柄的边界。
*   **LR 分析法**：通过一个强大的 DFA（状态机）来精确地识别句柄的出现，并决定何时进行规约。这是最通用、最准确的方法。

---
#### 1.4 工作台：符号栈

为了实现“移入-规约”这个过程，并有效地追踪我们已经“拼好”的部件，我们需要一个**符号栈**。

**工作流程**:
1.  **初始状态**: 栈为空，输入指针指向第一个 Token。
2.  **循环**:
    a.  **决策**: 分析器根据当前**栈顶的状态**和**下一个输入 Token**，来决定是“移入”还是“规约”。（决策的依据，就是不同分析方法的核心，比如 LR 分析表）。
    b.  **执行“移入”**: 从输入队列拿一个 Token，压入栈顶。
    c.  **执行“规约”**:
        i.  在栈顶找到句柄（比如 `αβ`）。
        ii. 把它从栈顶弹出。
        iii. 把对应的产生式左部非终结符 `A` 压入栈顶。
3.  **结束**:
    *   **成功**: 当栈里只剩下开始符号 `S`，且输入队列为空时，分析成功。
    *   **失败**: 如果在某个决策点，分析器发现既不能移入，也不能规约，则报告语法错误。

---
### 补充一：短语、直接短语与句柄 (与语法树的关系)

这些概念都是**基于语法树**来定义的，它们描述了语法树中不同“片段”的层次关系。

**我们先来看一棵语法树：**

*   **文法**: `E → E * T | T`, `T → T + F | F`, `F → id`
*   **句子**: `id * id + id`
*   **它的一个最右推导**: `E ⇒ E*T ⇒ E*T+F ⇒ E*T+id ⇒ E*F+id ⇒ E*id+id ⇒ T*id+id ⇒ F*id+id ⇒ id*id+id`

**对应的语法树：**
```
      E
      |
      E -- * -- T
      |       |
      T       T -- + -- F
      |       |       |
      F       F      id
      |       |
      id      id
```

**现在，我们来定义这些概念：**

#### 1. 短语 (Phrase)

*   **定义**: 语法树中的**任一棵子树**，其**所有末端节点 (叶子)** 从左到右连接起来形成的字符串，就是相对于该子树根节点的一个**短语**。
*   **直观理解**: 短语就是句子中一个**语法上可以被看作一个整体**的部分。
*   **例子 (看上面的树)**:
    *   以最顶层的 `E` 为根的子树，它的叶子是 `id * id + id`。所以 `id * id + id` 是 `E` 的一个短语。
    *   以中间的 `T` 为根的子树，它的叶子是 `id + id`。所以 `id + id` 是 `T` 的一个短语。
    *   以最左边的 `F` 为根的子树，它的叶子是 `id`。所以第一个 `id` 是 `F` 的一个短语。

#### 2. 简单短语 (Simple Phrase)

*   **定义**: 如果一棵子树的**高度只有2** (即根节点直接连接所有叶子节点)，那么这棵子树的叶子形成的短语，就叫做**简单短语**。
*   **直观理解**: 简单短语是一个**一步推导**就能得到的短语。它正好对应某个产生式的**右部**。
*   **例子**:
    *   `E → T` 这棵子树（最左边的 `E` 和 `T`），它的叶子是 `T` 的叶子，即 `id`。但它的高度不是2。
    *   `T → F` 这棵子树（最左边的 `T` 和 `F`），叶子是`id`。也不是。
    *   `F → id` 这棵子树，高度是2！所以，`id` 是一个简单短语。
    *   `T → T + F` 这棵子树，它的叶子是 `id + id`。但它的高度超过2了，所以 `id+id` 不是简单短语。

#### 3. 句柄 (Handle)

*   **PPT 的定义**: “**最左简单短语**”。
*   **定义**: 一个句型的**句柄**，是这个句型所对应的语法树中，**最左边的那棵高度为2的子树**的叶子节点串。
*   **直观理解**: 句柄就是当前这一步，**最应该被规约**的那个部分。它对应了**最右推导的逆过程**。
*   **为什么是最左？** 因为我们是从左到右扫描输入的，我们最先遇到的那个可以被一步规约的完整单元，就是我们当前能处理的句柄。
*   **例子**:
    *   对于句型 `id * id + id`，它的语法树中，最左边的、高度为2的子树是 `F → id`。所以，**第一个 `id` 就是句柄**。
    *   规约后，句型变成 `F * id + id`。
    *   对于 `F * id + id`，最左的简单短语是 `F` 本身（来自`T->F`）。规约后得到 `T * id + id`。
    *   ... 这个过程不断进行，每一次都规约“最左简单短语”，就是在模拟最右推导的逆过程。

**总结**：`短语 > 简单短语 > 句柄`。句柄是简单短语中最特殊、最靠左的一个，它是自下而上分析器每一轮的“操作目标”。

---
### 第二讲：算符优先分析 —— 一个简单的“热身”



#### **引言：我们的目标与视角**
在自下而上分析的世界里，我们的核心任务是**找到句柄 (Handle)** 并进行规约。算符优先分析法提供了一种简单直观的策略：**通过比较运算符之间的优先级来“框定”句柄的边界**。为了让这个策略行得通，我们必须在一套非常严格的“游戏规则”下进行。

---
**核心场景：分析句子 `a + b * c`**

*   **正确的语法结构**: `a + (b * c)`
*   **正确的句柄**: 在 `a+b*c` 中，第一个句柄是 `b`，然后是 `c`，然后是 `b*c`...  不，最直观的句柄应该是 `b*c` 这个整体。
*   **我们的目标**: 设计一种机制，能让计算机自动发现 `b*c` 是一个应该被优先“打包”（规约）的整体。

---

#### **1.1 准入许可证：算符文法 (Operator Grammar)**

不是所有的文法都有资格参与“算符优先”这个游戏。只有满足特定条件的**算符文法**才能入场。


**算符优先文法的条件：**
1.  **没有 `A → BC` 这种相邻的非终结符。**
2.  **没有 `A → ε` 产生式。**

**为什么要有这些条件？**
> 为什么如果允许 A → BC，分析器就找不到“路牌”了？为什么只有算符文法才能入场？

我们来做一个思想实验，假设我们**违反**了算符文法的规定。

*   **一个“坏”的文法 (非算符文法)**:
    1.  `E → T | E + T`
    2.  `T → F | T F`  (**违反！** `T` 和 `F` 两个非终结符相邻)
    3.  `F → id`

*   **一个推导过程**: `E ⇒ E+T ⇒ E+TF ⇒ E+Tid ⇒ E+Fid ⇒ E+idid ⇒ ...`
    *   在某个中间句型中，我们可能得到 `...id id...` 这样的结构，其中第一个 `id` 来自 `T`，第二个 `id` 来自 `F`。

**现在，我们来构造优先关系表。**
我们要确定 `id` 和 `id` 之间的关系。算法要求我们去文法里找模式。
*   我们找到了 `T → T F` 这条规则。
*   算法想确定 `LASTVT(T)` 和 `FIRSTVT(F)` 之间的关系。
    *   `LASTVT(T)` 包含 `id`。
    *   `FIRSTVT(F)` 包含 `id`。
*   但是，在 `T` 和 `F` 之间，**没有任何终结符**！我们的构造规则（`...aP...`, `...Pa...`, `...aPb...`）**全都用不上**！
    *   `a<∙b` 的规则是 `...aP...`，`a` 和 `P` 之间没有东西。
    *   `b∙>a` 的规则是 `...Pa...`，`P` 和 `a` 之间没有东西。
*   **结果**: 算法在 `T` 和 `F` 之间找不到任何“路牌”（终结符），因此**无法定义** `LASTVT(T)` 中的终结符和 `FIRSTVT(F)` 中的终结符之间的优先关系。优先关系表 `M[id, id]` 将是一个**空白格**。

**回到分析过程**:
当分析器处理 `...id * id...` 时（假设乘法用 `TF` 表示），栈顶是 `id`，输入是 `id`。分析器去查表 `M[id, id]`，发现是**空的**！它不知道该移入还是规约，程序卡住了。

**结论**:
“**不允许 `A → BC`**” 这个规定，就是为了从根本上杜绝这种“**关系真空**”的出现。它强制要求任意两个非终结符之间必须由一个终结符隔开（`A → B a C`）。这个 `a`，就成了 `B` 的结尾和 `C` 的开头之间的“**关系联络员**”或“**路牌**”，使得优先关系可以被明确地定义出来。

所以，只有算符文法才能保证我们能构造出一张**没有空白格**的、完整的优先关系表。这就是它的“入场券”。

---

#### **1.2 导航路牌：三种优先关系**

算符优先分析器的所有决策，都依赖于比较“栈顶终结符”和“当前输入符”这两种关系。

*   **`a <∙ b` (移入优先)**：`a` 的优先级低于 `b`。意味着一个更高优先级的语法结构以 `b` 开始了。**动作：移入**。
*   **`a ∙> b` (规约优先)**：`a` 的优先级高于 `b`。意味着以 `a` 结尾的一个高优先级语法结构已经完整了（句柄的尾部找到了）。**动作：规约**。
*   **`a ∙= b` (同级优先)**：`a` 和 `b` 是同一个语法结构的一部分，比如括号 `()`。**动作：移入**。

#### **1.3 核心特性：不对称性**

> **虽然有 `t₁ ∙> t₂`，不一定有 `t₂ <∙ t₁`。**

*   **为什么？** 因为 `<∙` 和 `∙>` 回答的是两个**完全不同**的问题。
    *   **`t₂ <∙ t₁` 问的是**：“当我看到 `t₂`，后面又来了 `t₁` 时，我是不是该**开启**一个由 `t₁` 主导的新结构？” (例如 `+` 遇到 `*`)
    *   **`t₁ ∙> t₂` 问的是**：“当我看到 `t₁`，后面又来了 `t₂` 时，是不是标志着我 (`t₁`) 所在的这个结构已经可以**结束**了？” (例如 `*` 遇到 `+`)
*   一个是“**开启**”的判断，一个是“**结束**”的判断。这两个判断的场景和逻辑都不同，所以它们的关系不是简单的数学大小比较，**不是对称的**。


---


#### 2.2 算符优先分析

想象一下，你正在编写一个只能处理简单加减乘除的计算器程序。你的任务是，拿到一个像 `id + id * id` 这样的、没有括号的 Token 序列，然后正确地计算出结果。

你的大脑知道应该“先算乘法，后算加法”。**算符优先分析法，就是把这个直觉“算法化”的一套机制。**

#### **核心思想：用“优先级”确定运算边界**

自下而上分析的核心是找到**句柄 (Handle)** 并进行规约。算符优先分析法认为，一个由运算符和操作数构成的句柄，它的边界一定是由**优先级的变化**来确定的。

*   当优先级**持续升高**时（比如 `+` 后面遇到 `*`），说明我们还在“爬坡”，句柄还没完整，应该继续向后看。
*   当优先级**突然下降**时（比如 `*` 后面遇到 `+`），说明“爬坡”结束了，一个高优先级的“山顶”（句柄）已经形成，是时候把它处理掉了（规约）。

#### **第一步：定义“路况”——三种优先关系**

为了将“优先级变化”这个概念形式化，我们定义了任意两个**终结符**（我们称之为“算符”）`θ₁` 和 `θ₂` 之间的三种关系：

1.  **`θ₁ <∙ θ₂` (移入优先)**
    *   **含义**: `θ₁` 的优先级**低于** `θ₂`。
    *   **比喻**: 遇到了一个**上坡路** `( `。
    *   **决策**: 句柄尚未形成，应该将 `θ₂` **移入 (Shift)** 栈中，继续前进。
    *   **例子**: `... + * ...`  =>  `+ <∙ *`

2.  **`θ₁ ∙> θ₂` (规约优先)**
    *   **含义**: `θ₁` 的优先级**高于** `θ₂`。
    *   **比喻**: 遇到了一个**下坡路** `) `。
    *   **决策**: 以 `θ₁` 结尾的句柄已经在栈顶形成，应该立即进行**规约 (Reduce)**。
    *   **例子**: `... * + ...`  =>  `* ∙> +`

3.  **`θ₁ ∙= θ₂` (同级优先)**
    *   **含义**: `θ₁` 和 `θ₂` 属于同一个句柄的“内部”。
    *   **比喻**: 在一段**平路**上行驶 ` = `。
    *   **决策**: 句柄还未完整，继续**移入**。
    *   **例子**: `( ... )` 或 `if ... then`  =>  `( ∙= )` , `if ∙= then`

#### **第二步：绘制“导航图”——构造算符优先关系表**

为了让分析器能快速查询这些关系，我们需要预先计算出一张二维表。

**前提条件**: 文法必须是**算符文法**（没有 `A→BC` 或 `A→ε`）。

**构造工具**: `FIRSTVT(P)` 和 `LASTVT(P)` 集合。
*   `FIRSTVT(P)`: `P` 能推导出的**第一个终结符**的集合。
*   `LASTVT(P)`: `P` 能推导出的**最后一个终结符**的集合。

**构造规则 (遍历所有产生式)**:
*   **寻找 `<∙` (上坡)**: 找 `...θ₁ P...` 结构，对于 `FIRSTVT(P)` 中的每个 `θ₂`，置 `θ₁ <∙ θ₂`。
*   **寻找 `∙>` (下坡)**: 找 `...P θ₁...` 结构，对于 `LASTVT(P)` 中的每个 `θ₂`，置 `θ₂ ∙> θ₁`。
*   **寻找 `∙=` (平路)**: 找 `...θ₁ θ₂...` 或 `...θ₁ P θ₂...` 结构，置 `θ₁ ∙= θ₂`。


---

#### **手册：计算 FIRSTVT 与 LASTVT 集合**

**目标**：为算符文法 G 中的每一个非终结符 `P`，计算其 `FIRSTVT(P)` 和 `LASTVT(P)` 集合。

#### **Part 1：计算 FIRSTVT(P) 集合**

`FIRSTVT(P)` 是 `P` 能推导出的串的**首终结符**集合。

##### **步骤 1：初始化**
为文法中的每一个非终结符 `P`，创建一个空集合 `FIRSTVT(P)`。

##### **步骤 2：迭代计算**
**重复**执行以下操作，直到在一整轮循环中，没有任何 `FIRSTVT` 集合再增大为止。

> **对于<u>每一个</u>产生式 `P → X₁ X₂ ... Xₖ`：**
>
> 1.  **检查 `X₁` (第一个符号)**
>     *   如果 `X₁` 是一个**终结符** `t`，则将 `t` 加入 `FIRSTVT(P)`。
>         *   **例子**: `T → * F ...`  =>  `*` 加入 `FIRSTVT(T)`。
>
> 2.  **检查 `X₁` 和 `X₂` (前两个符号)**
>     *   如果 `X₁` 是一个**非终结符** `Q`，并且产生式长度大于1（即 `X₂` 存在）：
>         *   如果 `X₂` 是一个**终结符** `t`，则将 `t` 加入 `FIRSTVT(P)`。
>             *   **例子**: `S → A b ...`  =>  `b` 加入 `FIRSTVT(S)`。

##### **步骤 3：传递闭包**
在上面的迭代**稳定后**，再执行一次传递闭包操作。

> **重复**执行以下操作，直到在一整轮循环中，没有任何 `FIRSTVT` 集合再增大为止。
>
> > **对于<u>每一个</u>产生式 `P → Q...` (右部以非终结符 `Q` 开头)：**
> >
> > *   将 **`FIRSTVT(Q)`** 的所有元素加入 **`FIRSTVT(P)`**。
> >     *   **例子**: `E → T ...`  =>  `FIRSTVT(E) = FIRSTVT(E) ∪ FIRSTVT(T)`。

*注意：将步骤2和3分开，或者合并在一起迭代，最终结果是一样的。分开可以使得逻辑更清晰：先找“直接”的，再做“传递”。*

---
#### **Part 2：计算 LASTVT(P) 集合**

`LASTVT(P)` 是 `P` 能推导出的串的**末终结符**集合。它的计算方法与 `FIRSTVT` **完全对称**。

##### **步骤 1：初始化**
为文法中的每一个非终结符 `P`，创建一个空集合 `LASTVT(P)`。

##### **步骤 2：迭代计算**
**重复**执行以下操作，直到在一整轮循环中，没有任何 `LASTVT` 集合再增大为止。

> **对于<u>每一个</u>产生式 `P → X₁ X₂ ... Xₖ`：**
>
> 1.  **检查 `Xₖ` (最后一个符号)**
>     *   如果 `Xₖ` 是一个**终结符** `t`，则将 `t` 加入 `LASTVT(P)`。
>         *   **例子**: `F → ( E )`  =>  `)` 加入 `LASTVT(F)`。
>
> 2.  **检查 `Xₖ₋₁` 和 `Xₖ` (最后两个符号)**
>     *   如果 `Xₖ` 是一个**非终结符** `Q`，并且产生式长度大于1（即 `Xₖ₋₁` 存在）：
>         *   如果 `Xₖ₋₁` 是一个**终结符** `t`，则将 `t` 加入 `LASTVT(P)`。
>             *   **例子**: `S → ... b A`  =>  `b` 加入 `LASTVT(S)`。

##### **步骤 3：传递闭包**
在上面的迭代**稳定后**，再执行一次传递闭包操作。

> **重复**执行以下操作，直到在一整轮循环中，没有任何 `LASTVT` 集合再增大为止。
>
> > **对于<u>每一个</u>产生式 `P → ...Q` (右部以非终结符 `Q` 结尾)：**
> >
> > *   将 **`LASTVT(Q)`** 的所有元素加入 **`LASTVT(P)`**。
> >     *   **例子**: `E → ... T`  =>  `LASTVT(E) = LASTVT(E) ∪ LASTVT(T)`。

---
好的，没问题。一旦你成功计算出了所有非终结符的 `FIRSTVT` 和 `LASTVT` 集合，构造**算符优先关系表**就成了一个非常直接的“**填表格**”工作。

---

#### **手册：构造算符优先关系表**

**目标**：为算符文法 G 中的任意一对终结符 `θ₁` 和 `θ₂`，确定它们之间的优先关系（`<∙`, `∙=`, `∙>`）。

---
##### **第 0 步：准备工作**

1.  **确认文法**：确保你的文法是**算符文法**。
2.  **计算辅助集**：确保你已经正确计算出了所有非终结符的 `FIRSTVT` 和 `LASTVT` 集合。
3.  **创建空表**：画一个二维表格，行和列都是文法中的**所有终结符**，再加上一个特殊的边界符 **`$`**。

---
##### **第 1 步：遍历产生式，确定所有关系**

**遍历文法中的<u>每一条</u>产生式，寻找下面三种模式：**

#### **模式一：寻找 `∙=` 关系 (终结符相邻)**

> **扫描每一个产生式的右部，寻找所有<u>相邻的终结符</u>。**
>
> **规则**: 如果在产生式中找到了 `... θ₁ θ₂ ...` 这种模式，那么就在优先表中设置：
> **`θ₁ ∙= θ₂`**
>
> **例子**:
> *   `F → ( E )` => 找到了 `( E )`。虽然 `(` 和 `)` 不直接相邻，但中间的 `E` 被视为“透明”。因此，我们寻找 `...θ₁ P θ₂...` 模式。
> *   **设置**: `( ∙= )`

*注意：`...θ₁ P θ₂...` 这种中间夹着一个非终结符的情况，也适用于 `∙=` 关系。*

#### **模式二：寻找 `<∙` 关系 (终结符“开启”一个非终结符)**

> **扫描每一个产生式的右部，寻找<u>终结符后面紧跟非终结符</u>的模式。**
>
> **规则**: 如果在产生式中找到了 `... θ₁ P ...` 这种模式：
> 1.  找到 `FIRSTVT(P)` 集合。
> 2.  对于 `FIRSTVT(P)` 中的**每一个**终结符 `θ₂`，都在优先表中设置：
>     **`θ₁ <∙ θ₂`**
>
> **例子**:
> *   `E → E + T` => 找到了 `+ T` 模式。
> *   假设 `FIRSTVT(T) = { *, (, id }`。
> *   **设置**:
>     *   `+ <∙ *`
>     *   `+ <∙ (`
>     *   `+ <∙ id`

#### **模式三：寻找 `∙>` 关系 (非终结符“结束于”一个终结符之前)**

> **扫描每一个产生式的右部，寻找<u>非终结符后面紧跟终结符</u>的模式。**
>
> **规则**: 如果在产生式中找到了 `... P θ₁ ...` 这种模式：
> 1.  找到 `LASTVT(P)` 集合。
> 2.  对于 `LASTVT(P)` 中的**每一个**终结符 `θ₂`，都在优先表中设置：
>     **`θ₂ ∙> θ₁`**
>
> **例子**:
> *   `E → E + T` => 找到了 `E +` 模式。
> *   假设 `LASTVT(E) = { +, *, ), id }`。
> *   **设置**:
>     *   `+ ∙> +`
>     *   `* ∙> +`
>     *   `) ∙> +`
>     *   `id ∙> +`

---
##### **第 2 步：处理边界符 `$`**

为了让分析能够正确开始和结束，我们还需要定义边界符 `$` 与其他所有终结符的关系。

> **对于文法的开始符号 `S`：**
>
> 1.  **处理开头**:
>     *   对于 `FIRSTVT(S)` 中的**每一个**终结符 `θ`，设置：
>         **`$ <∙ θ`**
>
> 2.  **处理结尾**:
>     *   对于 `LASTVT(S)` 中的**每一个**终结符 `θ`，设置：
>         **`θ ∙> $`**

---


#### **第三步：开始“驾驶”——算符优先分析算法**

现在，我们有了“导航图”（优先表），可以开始分析输入了。

**工作台**:
*   一个**符号栈**，栈底预置一个边界符 `$`。
*   一个**输入队列**，末尾预置一个边界符 `$`。

**算法流程**:

1.  **初始化**: `$` 入栈。
2.  **主循环**:
    a.  设 `k` 是栈顶的第一个终结符，`a` 是当前输入符号。
    b.  查询 `k` 和 `a` 的优先关系 `k ? a`。

    c.  **case `k <∙ a` 或 `k ∙= a`**:  // 上坡或平路
        i.  **移入 (Shift)**: 将 `a` 压入栈中。
        ii. 输入指针后移一位。

    d.  **case `k ∙> a`**: // 下坡，该规约了！
        i.  **寻找句柄**: 从栈顶开始，一个一个地向栈底回溯。当你看到一个终结符 k 时，再往前看一个，找到它左边的、离它最近的那个终结符 j。使得 f(j) < g(k)
        ii. 句柄就是从 j 的右边一个位置开始，到栈顶的全部内容（不包括 `j`）。
        iii. **规约 (Reduce)**: 将这个句柄从栈中弹出，然后压入一个**通用的非终结符**（比如 `N`）。
        iv. **注意**: **输入指针保持不动**，因为 `a` 还没有被处理，它将是下一轮比较的对象。

    e.  **case `关系为空` (error)**:
        i.  报告语法错误。

    f.  **case `k = $` 且 `a = $`**:
        i.  **接受 (Accept)**: 分析成功，结束。

#### **第四步：一个完整的例子**

*   **文法**: `E → E+T | T`, `T → T*F | F`, `F → id`
*   **输入**: `id + id * id $`
*   **优先关系 (部分)**: `+ <∙ *`, `* ∙> +`, `+ ∙> $`, `* ∙> $`, `$ <∙ id` ...

**模拟过程**:

| 栈 | 优先关系 | 输入 | 动作 |
| :--- | :--- | :--- | :--- |
| `$` | `$ <∙ id` | `^id + id * id $` | 移入 `id` |
| `$ id` | `id ∙> +` | `  ^+ id * id $` | 规约 `id` -> `N` |
| `$ N` | `$ <∙ +` | `  ^+ id * id $` | 移入 `+` |
| `$ N +` | `+ <∙ id` | `    ^id * id $` | 移入 `id` |
| `$ N + id`| `id ∙> *` | `      ^* id $` | 规约 `id` -> `N` |
| `$ N + N` | `+ <∙ *` | `      ^* id $` | 移入 `*` |
| `$ N + N *`| `* <∙ id` | `        ^id $` | 移入 `id` |
| `$ N+N*id`| `id ∙> $` | `           ^$` | 规约 `id` -> `N` |
| `$ N+N*N` | `* ∙> $` | `           ^$` | 规约 `N*N` -> `N` |
| `$ N + N` | `+ ∙> $` | `           ^$` | 规约 `N+N` -> `N` |
| `$ N` | `$ ∙= $` | `           ^$` | 接受！(这里假设 `$= $` 是接受) |

**注意**: 在实际算法中，栈里会同时有终结符和非终结符。比较时，我们会从栈顶向下找到第一个终结符。


---
#### **1. 素短语 (Prime Phrase)**

*   **定义**: 一个算符文法的句型中的一个子串，如果它至少包含一个终结符，并且它本身的两侧是具有更高优先级的终结符，或者它已经是整个句型的边界，那么这个子串就称为**素短语**。
    *   更形式化的说，对于句型 `...a S b...`，如果 `a <∙ S的第一个终结符` 且 `S的最后一个终结符 ∙> b`，那么`S`就是一个素短语。

*   **直观理解 (用“括号匹配”思想)**:
    > **素短语就是由一对 `<∙` 和 `∙>` 像括号一样“包”起来的、<u>最长</u>的那个符号串。**

*   **例子**:
    *   句子: `$ id + id * id $`
    *   优先关系链: `$ <∙ id ∙> + <∙ id ∙> * <∙ id ∙> $`
    *   我们来找 `<∙ ... ∙>` 这种模式：
        *   `$ <∙ id ∙> +`：`id` 是一个素短语。
        *   `+ <∙ id ∙> *`：`id` 是一个素短语。
        *   `* <∙ id ∙> $`：`id` 是一个素短语。
    *   如果我们已经规约了一部分，比如得到了 `$ N + N * N $`
    *   优先关系链: `$ <∙ + <∙ * ∙> $` (这里忽略了非终结符)
    *   我们找到了 `<∙ * ∙>` 这个模式。在栈里，它对应的是 `N*N`。所以 `N*N` 是一个素短语。

#### **2. 最左素短语 (Leftmost Prime Phrase)**

*   **定义**: 在一个句型中，**最左边的那个素短语**。
*   **核心关系**:
    > **最左素短语，就是算符优先分析中的“句柄”。**

*   **为什么？**
    *   算符优先分析算法的工作流程，就是不断地寻找**优先级最高的区域**并进行规约。
    *   这个“最高优先级”的区域，在符号串上就表现为由 `<∙` 和 `∙>` 包围的结构。
    *   由于我们是从左到右扫描的，我们找到的**第一个**完整的 `<∙ ... ∙>` 结构，自然就是**最左边的那个素短语**。

*   **算法的体现**:
    *   算符优先分析算法中，“**当 `k ∙> a` 时开始在栈中回溯查找最近的 `<∙`**” 这个动作，就是在**定位最左素短语（句柄）的边界**。

**总结**:
*   **素短语**是算符优先分析法能够识别的“语法单元”，是“短语”概念在算符文法中的一种简化替代品。
*   **最左素短语**就是分析器在每一步中要寻找的**句柄**。

---

#### 2.4 优缺点总结

*   **优点**:
    1.  **实现简单**: 算法逻辑直观，核心就是查表和比较，很容易手动实现。
    2.  **效率高**: 分析过程是线性的。
    3.  **擅长处理表达式**: 对于以中缀表示的算术表达式和逻辑表达式，这种方法非常有效。

*   **缺点**:
    1.  **能分析的文法有限**: 必须是算符文法，这排除了很多常见的语法结构。
    2.  **“假装”规约**: 它只能找到句柄的边界，但**无法确定**应该用哪一条产生式进行规约。因此，它**不能**用于构造详细的语法树，通常只能得到一个运算符的执行序列。
    3.  **错误处理能力弱**: 发现错误后，恢复起来比较困难。

---
### **补充三：优先函数 (Precedence Functions)**

我们之前讨论的**优先关系表**，在实现时有几个缺点：
1.  **占用空间大**: 如果有 `n` 个终结符，就需要一个 `n x n` 的二维数组来存储。
2.  **查找效率**：虽然查表很快，但还有提升空间。
3.  **构造复杂**：计算 `FIRSTVT` 和 `LASTVT` 有些繁琐。

**优先函数**提供了一种更优雅、更高效的替代方案。

*   **核心思想**:
    > 我们不存储两两之间的关系，而是为**每一个终结符** `θ` 分别赋予两个**整数值**：
    > *   **`f(θ)`**: 栈内优先函数 (In-Stack Precedence, ISP)
    > *   **`g(θ)`**: 栈外优先函数 (In-Coming Precedence, ICP)
    >
    > 然后，通过比较这两个整数的大小，来**动态地推导出**优先关系。

*   **推导规则**:
    *   如果栈顶终结符是 `θ₁`，当前输入是 `θ₂`：
        *   若 **`f(θ₁) < g(θ₂)`**，则 `θ₁ <∙ θ₂` (移入)。
        *   若 **`f(θ₁) > g(θ₂)`**，则 `θ₁ ∙> θ₂` (规约)。
        *   若 **`f(θ₁) = g(θ₂)`**，则 `θ₁ ∙= θ₂` (移入，通常用于括号)。

*   **`f` 和 `g` 的直观理解**:
    *   `f(θ)` (栈内/左边) 代表了这个运算符作为**一个运算的结尾**时的“坚守能力”。
    *   `g(θ)` (栈外/右边) 代表了这个运算符作为**一个运算的开始**时的“抢占能力”。

*   **一个经典的例子 (加减乘除)**:
    | 符号 θ | `f(θ)` (栈内) | `g(θ)` (栈外) |
    | :--- | :--- | :--- |
    | `+`, `-` | 2 | 1 |
    | `*`, `/` | 4 | 3 |
    | `(` | 0 | 5 |
    | `)` | - | 0 |
    | `id` | 6 | 5 |
    | `$` | 0 | 0 |

*   **我们来验证一下**:
    *   **比较 `+` (栈内) 和 `*` (栈外)**:
        *   `f(+) = 2`, `g(*) = 3`。
        *   `f(+) < g(*)` => `+ <∙ *` (移入)。**正确！**
    *   **比较 `*` (栈内) 和 `+` (栈外)**:
        *   `f(*) = 4`, `g(+) = 1`。
        *   `f(*) > g(+)` => `* ∙> +` (规约)。**正确！**
    *   **比较 `(` (栈内) 和 `id` (栈外)**:
        *   `f(() = 0`, `g(id) = 5`。
        *   `f(() < g(id)` => `( <∙ id` (移入)。**正确！**
    *   **比较 `+` (栈内) 和 `+` (栈外) (处理左结合性)**:
        *   `f(+) = 2`, `g(+) = 1`。
        *   `f(+) > g(+)` => `+ ∙> +` (规约)。这意味着 `a+b+c` 会被解析成 `(a+b)+c`，因为看到第二个 `+` 时，会先规约前面的 `a+b`。


---
好的，非常感谢你提供了 PPT 上的具体算法！这个算法和我之前介绍的“最长路径法”以及“迭代更新法”在思路上有所不同，但最终目标是一致的。

我将**严格按照你 PPT 上给出的这个算法**，为你重新编写一份清晰、详细的构造方法手册。

---

#### **手册：构造优先函数**

**目标**: 为每一个终结符 `θ`（包括边界符`#`或`$`），计算出两个整数值 `f(θ)` 和 `g(θ)`。

---

##### **第 1 步：构造优先关系方向图**

这一步的目标是，将抽象的 `n x n` 优先关系表，转换成一个具象的、节点之间有连接关系的图。

**规则：**

1.  **创建节点**:
    *   为**每一个**终结符 `a`（包括边界符 `#`），创建两个节点，分别命名为 `fₐ` 和 `gₐ`。

2.  **根据优先关系画有向边 (箭头)**:
    *   遍历优先关系表中的**每一个非空**关系：
        *   如果 **`a ∙> b`** 或 **`a ∙= b`**，则从 `fₐ` 画一条有向边到 `gᵦ`。
            *   **`fₐ → gᵦ`**
        *   如果 **`a <∙ b`** 或 **`a ∙= b`**，则从 `gᵦ` 画一条有向边到 `fₐ`。
            *   **`gᵦ → fₐ`**


---
##### **第 2 步：为每个节点赋值**

这一步的核心是计算每个节点的“**影响力范围**”。

**规则：**

> **对于<u>每一个</u>节点 `N`，它的值 `Value(N)` 等于<u>从该节点出发，沿着有向边所能到达的所有节点的总个数</u> (包括 `N` 节点自身)。**

**如何计算 (系统性方法)？**

直接“数”个数对于复杂的图很容易出错。我们可以使用图论中的“**可达性 (Reachability)**”算法，比如 **Floyd-Warshall 算法** 或多次 **深度/广度优先搜索 (DFS/BFS)**。

**一个更适合手动操作的步骤：**

1.  **为每个节点 `N`，计算它的“可达集” `Reachable(N)`**:
    *   `Reachable(N)` 初始化为 `{N}`。
    *   **重复**以下操作，直到集合不再变化：
        *   对于 `Reachable(N)` 中的每一个节点 `U`，找到所有从 `U` 出发的边 `U → V`。
        *   将所有这些 `V` 都加入到 `Reachable(N)` 中。
    *   这个过程实际上就是在计算图的**传递闭包 (Transitive Closure)**。

2.  **计算节点的值**:
    *   `Value(N) = |Reachable(N)|`  (即可达集中元素的个数)。

**例子**:
*   **图**: `fₐ → gᵦ`, `gᵦ → f_c`
*   **计算 `Value(fₐ)`**:
    *   `Reachable(fₐ)` 初始化为 `{fₐ}`。
    *   从 `fₐ` 可以到 `gᵦ` -> `Reachable(fₐ)` = `{fₐ, gᵦ}`。
    *   从 `gᵦ` 可以到 `f_c` -> `Reachable(fₐ)` = `{fₐ, gᵦ, f_c}`。
    *   集合不再变化。
    *   `Value(fₐ) = |{fₐ, gᵦ, f_c}| = 3`。
*   **计算 `Value(gᵦ)`**:
    *   `Reachable(gᵦ)` 初始化为 `{gᵦ}`。
    *   从 `gᵦ` 可以到 `f_c` -> `Reachable(gᵦ)` = `{gᵦ, f_c}`。
    *   集合不再变化。
    *   `Value(gᵦ) = |{gᵦ, f_c}| = 2`。
*   **计算 `Value(f_c)`**:
    *   `Reachable(f_c)` = `{f_c}`。
    *   `Value(f_c) = 1`。

---
##### **第 3 步：定义优先函数并检查**

1.  **定义函数**:
    *   对于每一个终结符 `a`，`f(a) = Value(fₐ)`。
    *   对于每一个终结符 `a`，`g(a) = Value(gₐ)`。

2.  **检查矛盾**:
    *   **这是至关重要的一步！** 构造出来的函数不一定就是正确的，必须回头验证。
    *   **遍历原始的优先关系表**中的每一个关系：
        *   如果原始关系是 **`a ∙> b`**，检查是否满足 **`f(a) > g(b)`**。
        *   如果原始关系是 **`a <∙ b`**，检查是否满足 **`f(a) < g(b)`**。
        *   如果原始关系是 **`a ∙= b`**，检查是否满足 **`f(a) = g(b)`**。

3.  **最终结论**:
    *   如果**所有**原始关系都得到了满足，那么你构造的 `f` 和 `g` 就是一组正确的优先函数。
    *   如果**存在任何一个**关系不满足（比如原始是 `a ∙> b`，但算出来 `f(a) ≤ g(b)`），那么**优先函数不存在**。这通常意味着原始的优先关系表中存在“**隐含的环**”，导致了赋值的矛盾。

这个 PPT 上的算法，通过计算每个节点“能影响多少个其他节点”来为其赋予一个权重值。这个权重值被用作优先级的度量。与我之前介绍的方法相比，它在构造图和赋值的规则上有所不同，但最终的**验证步骤**是共通的——无论用什么方法构造，结果必须符合原始的优先关系。

---
#### 2.5 算符优先分析法的出错处理

算符优先分析法的错误检测能力比较简单：
> **当栈顶终结符 `k` 和当前输入 `a` 之间的优先关系在表中是<u>空白</u>时，就检测到了一个错误。**

但是，它的错误恢复能力比较弱，因为它“看不见”非终结符，很难判断语法结构的整体情况。

**常见的出错处理方法：**

##### **1. 恐慌模式 (Panic Mode) 的简化版**

这是最简单、最常用的方法。

*   **策略**: 寻找一个具有“**定界**”意义的符号，然后跳过中间的所有内容。
*   **具体操作**:
    1.  当检测到错误时（比如 `M[k, a]` 为空），报告错误。
    2.  **扫描输入流**，不断地**丢弃**输入符号，直到遇到一个**高可信度的“同步符号”**，比如**分号 `;`** 或者**右括号 `)`**。
    3.  **同时，从栈中不断弹出符号**，直到栈顶的符号与刚刚找到的同步符号能够形成一个**合法的优先关系**（比如 `k <∙ ;` 或 `k ∙= )`）。
    4.  从这个点开始，恢复正常的分析过程。

*   **优点**: 实现简单。
*   **缺点**: 可能会丢弃大量的有效代码，导致连锁错误。

##### **2. 基于优先关系的局部修正**

这种方法更智能一些，它尝试对错误进行小范围的“修复”。

*   **策略**: 当 `M[k, a]` 为空时，分析器假定这里可能缺少了某个运算符，或者多了一个操作数等等。它会根据 `k` 和 `a` 的**优先函数值**来“猜测”应该是什么关系。

*   **几种可能的修复场景**:
    1.  **错误类型：`...id id...` (操作数相邻)**
        *   **检测**: `M[id, id]` 可能是空的。
        *   **修复**: 假设中间缺少了一个运算符，比如 `+`。在输入流中**插入**一个 `+`，然后继续分析。
    2.  **错误类型：`... + * ...` (运算符相邻)**
        *   **检测**: `M[+, *]` 可能是空的。
        *   **修复**: 假设中间缺少了一个操作数 `id`。**压入**一个代表 `id` 的符号到栈中，然后继续分析。
    3.  **错误类型：`... + ) ...`**
        *   **检测**: `M[+, )]` 关系是 `+ ∙> )`，分析器会尝试规约 `+` 左边的内容。但如果左边内容不合法（比如只有一个 `(`)，规约会失败。
        *   **修复**: 假设 `(` 和 `+` 之间缺少操作数，或者 `+` 是多余的。可以尝试**删除** `+` 或者**弹出**栈里的 `(`。

*   **优点**: 能够提供更具体的错误修复建议，IDE 中的一些简单语法纠错功能就基于类似的思想。
*   **缺点**: 实现非常复杂，需要为每一种可能的“空白格”都预先定义好修复策略，容易引入新的错误。

**总结**:
算符优先分析的错误处理，不像 LL(1) 或 LR 那样有 `FOLLOW` 集等系统性的工具可以依赖。它的错误恢复更多是基于一些启发式的、经验性的规则，其中“恐慌模式”是最基本和可靠的保底策略。


---
### **第三讲：LR 分析法入门**

#### **引言：为什么需要 LR 分析法？**

到目前为止，我们已经探索了自下而上分析的“世界地图”，并了解了两个关键地点：

1.  **理论的“圣杯”：规范规约 (Canonical Reduction)**
    *   **它是什么？** 一种**最理想、最完美**的自下而上分析过程，是“最右推导”的精确逆过程。
    *   **它的优点？** 它能处理**最大范围**的上下文无关文法，并且能构造出唯一的、正确的语法树。
    *   **它的问题？** 它只是一个**理论目标**。它告诉我们“应该做什么”（在每一步都准确找到句柄并规约），但**没有告诉我们“具体要怎么做”**。如何仅凭从左到右的扫描，就能准确无误地识别出那个“最右推decin的逆过程”中的句柄？这是一个巨大的挑战。

2.  **一个“聪明的捷径”：算符优先分析法 (Operator-Precedence Parsing)**
    *   **它是什么？** 一种试图解决“如何找句柄”问题的**简化方案**。
    *   **它的策略？** 放弃理解完整的语法结构，只通过比较相邻**终结符**的优先级，来“框定”出**最左素短语**作为句柄的近似替代品。
    *   **它的优点？** 实现简单，对于表达式类文法很有效。
    *   **它的致命缺陷？**
        *   **文法限制太强**：必须是算符文法，连 `E → T E'` 这种相邻非终结符的规则都处理不了。
        *   **规约“盲目”**：它只知道句柄的边界，但**不知道**应该用 `E→T` 还是 `T→F` 来规约。因此，它无法构建精确的语法树，能力非常有限。

**三者的关系，就像寻找宝藏：**

> **规范规约** 告诉我们：“宝藏（句柄）确实存在，而且每一步只有一个是真的。”
>
> **算符优先分析** 提供了一张“**简陋的藏宝图**”，它能大致圈出宝藏可能在的区域，但地图不清晰，而且很多地方都画不了。
>
> **LR 分析法** 则提供了一台“**精密的 GPS 导航仪**”。它能严格地、精确地、一步不差地引导我们找到每一个真正的宝藏（句柄），并且告诉我们这个宝藏的“型号”（具体是哪个产生式）。

**所以，LR 分析法的历史使命就是：**
> **为“规范规约”这个完美的理论目标，提供一个通用的、强大的、可实现的算法。**

它结合了两者的优点：既有规范规约的**强大能力和准确性**，又有像算符优先分析那样的**机械化、基于查表**的实现方式。

---
#### **3.1 LR 分析器：一台通用的“移入-规约”状态机**

现在，我们来揭开这台“精密 GPS 导航仪”的内部构造。

一个 LR 分析器，无论它具体是 SLR(1), LALR(1) 还是 LR(1)，它的**物理结构**和**工作流程**都是完全一样的。

##### **核心组件 (The Hardware)**

1.  **输入缓冲区 (Input)**: 存放 Token 序列，以 `$` 结尾。
2.  **分析栈 (Stack)**: 这是 LR 分析的“**短期记忆**”。与 LL 分析不同，LR 的栈里存放的不是文法符号，而是**状态编号 (State Numbers)**。栈顶的状态代表了分析器对**已经读过的所有输入**的全部理解。
3.  **总控程序 (Driver)**: 一个**固定的、与文法无关**的算法。它的工作就是循环执行“看-查-动”的流程。
4.  **LR 分析表 (The Software/Map)**: 这是 LR 分析器的“**大脑**”，包含了所有的决策逻辑。它由两部分构成：
    *   **ACTION 表**: 指示“看到**终结符**时该做什么”。
    *   **GOTO 表**: 指示“规约出**非终结符**后该去哪里”。

##### **工作循环 (The "See-LookUp-Act" Loop)**

总控程序的逻辑极其简单：

> **`while (true)`**:
> 1.  **看 (See)**:
>     *   看**栈顶的状态**，记为 `s`。
>     *   看**当前的输入符号**，记为 `a`。
> 2.  **查 (Look Up)**:
>     *   在 **ACTION 表**中查询 `ACTION[s, a]`。
> 3.  **动 (Act)**:
>     *   根据查询结果，执行四种动作之一。

##### **四种动作 (The Four Actions)**

1.  **移入 (Shift s')**: `ACTION[s, a] = shift s'`
    *   **动作**: 将新状态 `s'` 压入栈顶，并将输入指针后移一位。
    *   **含义**: 当前的输入 `a` 是句柄的一部分，但句柄还不完整。我们需要继续读入更多符号。

2.  **规约 (Reduce r)**: `ACTION[s, a] = reduce r` (r 是产生式 `A → β` 的编号)
    *   **动作**:
        a.  从栈中弹出 `|β|` (β的长度) 个状态。
        b.  此时，新的栈顶状态是 `s'`。
        c.  查询 **GOTO 表**: `GOTO[s', A]`，得到新状态 `s_new`。
        d.  将 `s_new` 压入栈顶。
    *   **含义**: 在状态 `s` 时，我们已经看完了整个句柄 `β`。现在执行规约，并根据 GOTO 表跳转到识别出 `A` 之后的新状态。

3.  **接受 (Accept)**: `ACTION[s, $] = accept`
    *   **动作**: 宣布分析成功。
    *   **含义**: 整个输入已经被成功规约为开始符号。

4.  **报错 (Error)**: `ACTION[s, a]` 是空白格
    *   **动作**: 调用错误恢复程序。
    *   **含义**: 在当前状态 `s` 下，绝不应该看到输入 `a`。
---
### **补充四：前缀、活前缀与有效项目**

这些概念是为了**从理论上精确地描述 LR 分析过程中栈里内容的性质**。

#### **1. 前缀 (Prefix)**

*   **定义**：对于一个句型 `αβγ`，它的任何一个起始部分，如 `α`, `αβ` 等，都称为它的**前缀**。
*   **直观理解**：就是字符串的“开头部分”。

#### **2. 活前缀 (Viable Prefix)**

*   **定义**：一个句型的**活前缀**，是指该前缀是**某个规范规约过程**中（即最右推导的逆过程），在某一步**分析栈**中可能出现的内容。
*   **直观理解**: “活”字是关键。它意味着这个前缀**是有“前途”的**，它**没有包含句柄之后**的任何符号。也就是说，从这个前缀出发，**有可能**继续移入更多的符号，最终形成一个合法的句型。
    *   `...<句柄>...`，如果你的前缀已经越过了句柄的右边界，那它就不是“活”的了，因为它已经错过了规约的时机。
*   **例子**:
    *   **最右推导**: `E ⇒ T ⇒ T*F ⇒ T*id`
    *   **句型**: `T*id`
    *   **句柄**: `id`
    *   **活前缀**: `T`, `T*` 都是活前缀。因为分析器在栈里依次出现 `T` 和 `T*` 时，句柄 `id` 还没有被完全读入。
    *   `T*id` **不是**活前缀，因为它已经包含了整个句柄。
    *   `T*i` **不是**活前缀（假设 `id` 是一个整体）。

**核心关系**
> **我们构造的那个项目集 DFA，它的唯一作用，就是为了<u>识别</u>文法的所有<u>活前缀</u>。**
>
> 当分析器从左到右读入一个字符串时，只要它能顺着 DFA 的路径一直走下去，就说明到目前为止，栈里的内容（所代表的前缀）是一个**活前缀**。一旦它无路可走，就说明输入出错了。

#### **3. 有效项目 (Valid Item)**

*   **定义**：对于一个活前缀 `γ = αβ`，如果存在一个从 `S'` 的最右推导 `S' ⇒ ... ⇒ αAω ⇒ αβω`，那么项目 `[A → β∙]` 就被称为是对于活前缀 `γ` 的一个**有效项目**。
*   **直观理解**:
    > **一个状态（项目集）`I` 中的所有项目，就是对于某个活前缀 `γ` 的<u>所有</u>有效项目的集合。**

*   **这个概念把“活前缀”和“项目集”联系了起来。** 它在说：
    *   当我们分析器识别了一个活前缀 `γ`，并进入了状态 `I = goto(I₀, γ)` 时。
    *   `I` 里面的每一个项目 `[A → β∙]`，都在告诉我们一种可能性：“你刚刚识别的这个 `γ`，它的尾部可能是一个 `β`，并且这个 `β` 将来可能被规约为 `A`。”
    *   **例子**:
        *   活前缀 `T*` 对应某个状态 `I`。
        *   这个状态 `I` 里一定有一个项目 `[T → T*∙F]`。
        *   这个项目就是对于 `T*` 的一个**有效项目**。它告诉我们，`T*` 已经识别完毕，接下来要找一个 `F`，以便将来把 `T*F` 规约为 `T`。
---

#### 3.2 LR(0) 项目与状态机构造 

**我们的目标**: 构造出 LR 分析器的“大脑”——**ACTION 表**和 **GOTO 表**。

**核心思想**:
> **LR 分析器的每一个“状态”，都对应着一个“项目集 (Set of Items)”。**
>**LR 分析法的全部目的，就是通过预先计算，为这个“瞎子”分析器，构建一个强大的“记忆和预测系统”。**
> 这个系统，就是我们构造的**项目集 DFA**。
> 这个项目集，精确地描述了分析器在识别过程中的**所有可能性**，即“我们目前可能正在匹配哪条规则，并且匹配到什么进度了”。
---


**项目集 DFA 的真正含义：编码了上下文的“状态”**


> **DFA 中的一个状态 `I` (项目集)，就是分析器在某个时刻的“记忆快照”。它精确地编码了到目前为止，我们已经识别出的语法片段（活前缀），能够用来推导出哪些更大的语法结构。**

**一个比喻：拼图**

*   **文法**: 是一整盒拼图的所有“小目标”（比如“拼出蓝色天空”、“拼出红色屋顶”）。
*   **输入**: 是一堆散乱的拼图碎片。
*   **分析栈**: 是你已经拼好的一部分。
*   **一个状态 (项目集)**: 是对你已拼好部分的**解读**。

**场景**: 你已经拼好了一块蓝色的区域（栈里的内容），现在你拿起一块新的蓝色碎片（下一个输入）。

*   **这个状态 `I` (项目集) 就在告诉你**:
    *   “你手头的这块蓝色区域，可能是‘天空’的一部分 (`Sky → Blue∙...`)。”
    *   “也可能是‘大海’的一部分 (`Sea → Blue∙...`)。”
    *   “如果你接下来拼上一块云朵，我们就会进入‘确定是天空’的状态 (`goto(I, cloud) = J_sky`)。”
    *   “如果你接下来拼上一朵浪花，我们就会进入‘确定是大海’的状态 (`goto(I, wave) = J_sea`)。”

**所以，DFA 的每一条路径，都代表了对输入的一种特定语法结构的识别过程。**

---

##### **3.2.1 核心绘图工具：LR(0) 项目 (Item)**

*   **什么是“项目”？**
    *   一个 LR(0) 项目，就是一个在产生式右部的**某个位置**加了一个“**进度点 `∙`**”的产生式。
    *   **例子**: 对于产生式 `A → XYZ`，我们可以得到四个不同的项目：
        *   `A → ∙XYZ` : 我们正**准备**识别一个 `A`，还未开始。
        *   `A → X∙YZ` : 我们已经成功识别了一个 `X`，**接下来期望**看到一个 `Y`。
        *   `A → XY∙Z` : 我们已经成功识别了 `XY`，**接下来期望**看到一个 `Z`。
        *   `A → XYZ∙` : 我们已经成功识别了完整的 `XYZ`，现在是时候**进行规约**了。

*   **项目的含义**:
    *   一个项目 `[A → α∙β]` 包含了两种信息：
        1.  我们当前可能正在匹配的产生式是 `A → αβ`。
        2.  我们已经成功识别了 `α` 部分，接下来期望识别 `β` 部分。

---

##### **3.2.2 关键操作一：闭包 (Closure) 运算**

*   **问题**: 仅有 `A → ∙XYZ` 这个项目是不够的。如果我们要开始识别 `XYZ`，那么我们首先需要识别 `X`。如果 `X` 本身又是一个非终结符（比如 `X → p|q`），那么我们就**也**进入了“准备识别 `p`”和“准备识别 `q`”的状态。
*   **闭包运算 `CLOSURE(I)` 的作用**:
    > **从一个已有的项目集 `I` 出发，不断地“丰富”和“扩展”它，直到所有“待办事项”都被明确列出为止。**

*   **算法**:
    1.  将 `I` 中的所有项目加入结果集 `J`。
    2.  **重复**以下步骤，直到 `J` 不再增大：
        *   在 `J` 中寻找一个形如 `[A → α∙Bβ]` 的项目 (进度点 `∙` 后面是一个**非终结符 `B`**)。
        *   找到文法中 `B` 的所有产生式 `B → γ₁ | γ₂ | ...`。
        *   将这些产生式对应的**初始项目** `[B → ∙γ₁]`, `[B → ∙γ₂]`, ... 全部加入到 `J` 中（如果它们不在 `J` 里的话）。

*   **直观理解**:
    *   闭包运算就是在回答：“如果我的光标 `∙` 后面遇到了一个非终结符 `B`，那么我实际上也需要**同时准备好**开始识别 `B` 的所有可能性。”

*   **为什么要做闭包 (Closure)？—— 准备好所有“下一步可能性”**
   *   **原因**: 自上而下和自下而上在这里交汇了！
   *   **场景**: 你当前的项目是 `[A → α∙Bβ]`。从自下而上的角度，你已经识别了 `α`。但为了能最终识别出 `A`，你接下来**必须**识别出一个 `B`。
   *   **如何识别 `B`？** 你必须**从头开始**，尝试 `B` 的所有产生式，比如 `B → γ₁ | γ₂`。
   *   **闭包的本质**: 这是一个“**自上而下的预测**”步骤。它在说：“为了完成我自下而上的大目标 `A`，我需要启动一个自上而下的子任务，去识别 `B`。因此，我必须把 `[B → ∙γ₁]` 和 `[B → ∙γ₂]` 也加入到我当前的可能性列表中。”
   *   **不做闭包会怎样？** 你的状态信息就不完整。你只知道你要找 `B`，但不知道 `B` 长什么样，也不知道该如何开始识别它。

---

##### **3.2.3 关键操作二：goto(I, X) 函数**

*   **问题**: 如果我们当前处于状态 `I`（一个项目集），并且成功地识别（移入）了一个符号 `X`，那么我们应该**转移到哪个新状态**？
*   **`goto(I, X)` 函数的作用**:
    > **计算出在状态 `I` 识别了符号 `X` 之后，所到达的那个新的项目集（新状态）。**

*   **算法**:
    1.  创建一个空的项目集 `J`。
    2.  对于 `I` 中的**每一个**形如 `[A → α∙Xβ]` 的项目（进度点 `∙` 后面正好是 `X`）：
        *   将“**进度点后移一位**”得到的新项目 `[A → αX∙β]` 加入到 `J` 中。
    3.  **最终结果**: `goto(I, X) = CLOSURE(J)`。
        *   **关键**：在移动了所有相关的进度点之后，得到的新集合可能又需要被“丰富和扩展”，所以我们必须对这个新集合**再做一次闭包运算**。
*   **2. 为什么要做 goto？—— 在识别路径上“前进一步”**

   *   **原因**: 这是状态机最基本的**状态转移**功能。
   *   **场景**: 你当前在状态 `I`，并且成功地识别（移入）了一个符号 `X`。
   *   **goto 的本质**: 它在回答：“基于我们之前的所有可能性（状态 `I`），在成功识别了一个 `X` 之后，我们的新可能性集合（新状态 `J`）是什么？”
   *   **`goto(I, X)` 的计算过程，就是在模拟这个“前进一步”**:
       1.  它先把 `I` 中所有“正在等待 `X`”的项目（`[A → α∙Xβ]`）拿出来。
       2.  把它们的进度点 `∙` 跨过 `X`，变成 `[A → αX∙β]`。这代表“我们刚刚成功识别了 `X`”。
       3.  然后，对这个新集合再做一次**闭包**。因为进度点 `∙` 移动到了 `β` 的前面，如果 `β` 以非终结符 `C` 开头，我们又需要启动一个新的“自上而下”的子任务去识别 `C`。
   *   **不做 goto 会怎样？** 你就无法构建状态之间的转移关系，整个 DFA 地图就画不出来。
---

##### **3.2.4 构造 LR(0) 项目集族 (状态集合)**

现在我们有了两个核心工具，就可以开始绘制整张“地图”了。这个地图的官方名称叫“**LR(0) 项目集规范族 (Canonical Collection)**”。

**算法**:
1.  **增广文法 (Augmented Grammar)**: 在开始前，为原始文法增加一条新的产生式 `S' → S`，其中 `S'` 是新的开始符号。
    *   **为什么？** 这为整个分析过程提供了一个唯一的“起点”和唯一的“终点”（当规约到 `S'` 时，分析就成功了）。
2.  **创建初始状态 `I₀`**:
    *   `I₀ = CLOSURE({[S' → ∙S]})`。
3.  **创建状态集合 `C`**:
    *   `C = {I₀}`。同时创建一个“待处理列表”，放入 `I₀`。
4.  **循环扩展**:
    *   只要“待处理列表”不为空：
        *   从中取出一个项目集 `I`。
        *   对于文法中的**每一个**符号 `X`（包括终结符和非终结符）：
            *   计算 `J = goto(I, X)`。
            *   如果 `J` 非空，并且 `J` 不在 `C` 中，就把 `J` 加入 `C` 和“待处理列表”。
            *   记录下 `I` 经过 `X` 可以到达 `J`。

**这个过程，本质上就是在构造一个** DFA (确定有限自动机)！**
*   **DFA 的状态**: 就是我们构造出的每一个项目集 `Iᵢ`。
*   **DFA 的转换**: 就是 `goto` 函数定义的路径 `Iᵢ --X--> Iⱼ`。
*   这个 DFA 有一个非常重要的名字：**识别文法活前缀的 DFA (DFA for Viable Prefixes)**。“活前缀”指的是在规约过程中，栈里可能出现的任何前缀。
---
<img width="1400" height="759" alt="image" src="https://github.com/user-attachments/assets/b2452727-1711-46fc-9315-fd75fcce7c5c" />

---
### **补充二：LR(0) 的两大冲突**

冲突的根源在于，LR(0) 做决策时**只看当前状态**，不看下一个输入符号。

当一个状态（项目集）内部，**同时包含了多种“行动指令”**时，冲突就发生了。

#### **1. 移入-规约冲突 (Shift-Reduce Conflict)**

*   **定义**: 一个状态（项目集）中，**同时存在**一个**移入项目**和一个**规约项目**。
*   **状态 `I` 的形态**:
    *   包含一个移入项目 `[A → α∙aβ]` ( `∙` 后面是终结符 `a` )
    *   **并且**包含一个规约项目 `[B → γ∙]`
*   **分析器的困惑**:
    > 当我处于状态 `I` 时，我该怎么办？
    > 1.  **移入 (Shift)**：根据项目 `[A → α∙aβ]`，我应该期待下一个输入是 `a`，并把它移入栈中。
    > 2.  **规约 (Reduce)**：根据项目 `[B → γ∙]`，我已经识别完了一个完整的 `γ`，我应该立刻把它规约为 `B`。
*   **LR(0) 的“天真”之处**: 它不管下一个输入是什么，只要看到 `[B → γ∙]`，就想对**所有**可能的输入都执行规约。这必然会导致它和 `shift` 动作打架。

*   **经典例子：`if-else` 文法**
    `S → i S | i S e S` (`i`=if, `e`=else)
    *   在分析 `i S` 之后，会到达一个状态，其中包含：
        *   `[S → i S ∙]` (规约项目)
        *   `[S → i S ∙ e S]` (移入项目，期待 `e`)
    *   **冲突**: 当下一个输入是 `e` 时，分析器不知道是该把 `e` 移入（匹配 `else`），还是该把 `iS` 规约为 `S`（认为没有 `else`）。这就是经典的“**悬垂 else (dangling else)**”问题。

#### **2. 规约-规约冲突 (Reduce-Reduce Conflict)**

*   **定义**: 一个状态（项目集）中，**同时存在两个或更多个不同**的**规约项目**。
*   **状态 `I` 的形态**:
    *   包含一个规约项目 `[A → α∙]`
    *   **并且**包含另一个规约项目 `[B → β∙]`
*   **分析器的困惑**:
    > 当我处于状态 `I` 时，我已经识别完了一个句柄。但是，栈顶的这个句柄，到底是应该被看作是 `α` 并规约为 `A` 呢？还是应该被看作是 `β` 并规约为 `B` 呢？
*   **LR(0) 的决策**: 它不知道该用哪条规则，分析失败。

*   **例子**:
    *   `S → A | B`
    *   `A → x`
    *   `B → x`
    *   当分析器移入 `x` 后，会到达一个状态，其中包含：
        *   `[A → x∙]`
        *   `[B → x∙]`
    *   **冲突**: 此时，分析器不知道该把 `x` 规约为 `A`，还是规约为 `B`。

---


### **手册：LR(0) 分析法基础题目解题步骤**

#### **题型一：列出文法的所有 LR(0) 项目**

**目标**: 写出所有产生式在所有可能位置加了 `∙` 后的形式。

**步骤**:

1.  **增广文法 (Augment the Grammar)**:
    *   **第一步永远是增广文法！** 如果原始文法的开始符号是 `S`，则添加一条新的产生式 `S' → S`。`S'` 是新的开始符号。
    *   **原因**: 为整个分析过程提供一个唯一的“总目标”和清晰的“接受”点。

2.  **逐条列出**:
    *   遍历**增广后**的文法中的**每一条**产生式。
    *   对于一条产生式 `A → X₁X₂...Xₙ`，它有 `n+1` 个可以放置 `∙` 的位置。
    *   从左到右，依次写出这 `n+1` 个项目：
        *   `A → ∙X₁X₂...Xₙ`
        *   `A → X₁∙X₂...Xₙ`
        *   ...
        *   `A → X₁X₂...Xₙ∙`
    *   **特殊情况**: 如果产生式是 `A → ε`，它只有一个项目：`A → ∙`。

3.  **整理与计数**:
    *   将所有项目清晰地列在一起。
    *   如果题目要求，可以统计一下总共有多少个项目。

**例子**:
*   **文法**: `S → aS | b`
*   **1. 增广**: `S' → S`, `S → aS | b`
*   **2. 列出**:
    *   `S' → ∙S`
    *   `S' → S∙`
    *   `S → ∙aS`
    *   `S → a∙S`
    *   `S → aS∙`
    *   `S → ∙b`
    *   `S → b∙`

---
#### **题型二：构造 LR(0) 项目集规范族及识别活前缀的 DFA**

**目标**: 画出 LR(0) 分析器的“状态转换图”，其中每个状态都是一个项目集。

**步骤**:

1.  **增广文法**: 和题型一一样，这是第一步。

2.  **计算初始状态 `I₀`**:
    *   从增广文法的初始项目 `[S' → ∙S]` 开始。
    *   计算它的闭包：`I₀ = CLOSURE({[S' → ∙S]})`。
        *   **闭包操作 (复习)**:
            *   将初始项目放入集合。
            *   反复检查集合中 `∙` 后面是非终结符 `B` 的项目，并将 `B` 的所有初始项目 `[B → ∙γ]` 加入集合，直到集合不再增大。
    *   给这个集合命名为 `I₀`。

3.  **构建状态集 `C` 和“待办列表 `W`”**:
    *   `C = {I₀}`
    *   `W = {I₀}`

4.  **主循环 (广度优先)**:
    *   **只要 `W` 不为空**:
        a.  从 `W` 中**取出**一个项目集 `I`。
        b.  **遍历文法中的<u>所有</u>符号 `X`** (包括所有终结符和非终结符)。
        c.  **对于每一个 `X`**，计算 `J = goto(I, X)`:
            i.  **`goto` 操作 (复习)**:
                1.  找出 `I` 中所有形如 `[A → α∙Xβ]` 的项目。
                2.  将它们的 `∙` 后移一位，形成一个新核心项目集 `J_core = {[A → αX∙β], ...}`。
                3.  `J = CLOSURE(J_core)`。
            ii. **检查 `J`**:
                *   如果 `J` 是一个**全新的**、**不在 `C` 中**的项目集：
                    *   把它加入 `C`。
                    *   把它加入“待办列表 `W`”。
                    *   给它一个新名字，比如 `I₁`, `I₂`, ...
                *   在你的图纸上，画一条从状态 `I` 到状态 `J` 的有向边，并标记为 `X`。

5.  **结束**:
    *   当“待办列表 `W`”为空时，说明所有可达的状态都已找到，构造完成。

**最终产物**:
*   **项目集规范族**: 就是集合 `C = {I₀, I₁, ..., Iₙ}`。
*   **识别活前缀的 DFA**: 就是你根据 `goto` 关系画出的那张状态转换图。

**做题技巧**:
*   **保持条理**: 在纸上清晰地分块写出每个项目集 `Iᵢ`。
*   **不要遗漏**: 对于每个 `I`，确保你检查了**所有**可能的文法符号 `X` 的 `goto`。
*   **善用标记**: 对于已经处理过的项目集，在旁边打个勾，避免重复劳动或遗漏。
*   **闭包做全**: 每次计算 `goto` 后，**千万不要忘记**对结果再做一次 `CLOSURE`。这是最容易出错的地方！

---


### **3.3 SLR(1) 分析 —— 引入 FOLLOW 集**

#### **3.3.1 构造 LR(0) 分析表：一个“天真”的尝试**

LR(0) 的“0”意味着，它在做决策时，**完全不向后看 (0 Token Lookahead)**。它仅凭当前所在的状态，就试图做出决定。

**构造 ACTION 表和 GOTO 表的算法：**

1.  首先，使用我们上一讲的方法，构造出文法的 **LR(0) 项目集规范族** `{I₀, I₁, ..., Iₙ}` 和 **`goto` 函数**。
2.  **GOTO 表的填写**：
    *   这一步非常直接。如果 `goto(Iᵢ, A) = Iⱼ` (A是非终结符)，那么就在 `GOTO[i, A]` 处填入 `j`。

3.  **ACTION 表的填写 (核心规则)**：
    *   遍历每一个项目集 `Iᵢ`：
        a.  **处理移入 (Shift)**：
            *   如果在 `Iᵢ` 中有一个项目 `[A → α∙aβ]` ( `∙` 后面是**终结符 `a`**)，并且 `goto(Iᵢ, a) = Iⱼ`。
            *   那么，在 `ACTION[i, a]` 处填入 **`shift j`** (或 `sj`)。

        b.  **处理规约 (Reduce)**：
            *   如果在 `Iᵢ` 中有一个**规约项目** `[A → β∙]` ( `∙` 在最末尾，且 `A` 不是增广开始符号 `S'`)。
            *   那么，**对于<u>所有</u>的终结符 `t`** (包括 `$`)，都在 `ACTION[i, t]` 处填入 **`reduce A → β`** (或 `r_k`，k是产生式编号)。
            *   **这就是 LR(0) 最“天真”的地方！** 它不管下一个输入是什么，只要看到一个规约项目，就想进行规约。

        c.  **处理接受 (Accept)**：
            *   如果在 `Iᵢ` 中有项目 `[S' → S∙]` (增广文法的规约项目)。
            *   那么，在 `ACTION[i, $]` 处填入 **`accept`**。

#### **3.3.2 LR(0) 的先天不足：冲突 (Conflict)**

当我们按照上面“天真”的 LR(0) 规则去填表时，很快就会发现问题：**同一个单元格 `ACTION[i, a]`，可能会被填入多个不同的动作！** 这就是**冲突**。

**冲突的两种类型：**

1.  **移入-规约冲突 (Shift-Reduce Conflict)**:
    *   **原因**: 表格的同一个单元格，既要填一个 **`shift`** 动作，又要填一个 **`reduce`** 动作。
    *   **例子**: 在项目集 `Iᵢ` 中，**同时存在**:
        *   `[A → α∙aβ]` (要求在看到 `a` 时 `shift`)
        *   `[B → γ∙]` (要求在看到**任何**符号时都 `reduce`)
    *   **分析器的困惑**: 当我处于状态 `i`，看到输入 `a` 时，我到底是应该移入 `a`，期待构成一个更长的 `αaβ` 呢？还是应该立刻将 `γ` 规约为 `B` 呢？

2.  **规约-规约冲突 (Reduce-Reduce Conflict)**:
    *   **原因**: 表格的同一个单元格，要填入**两个或更多个不同**的 **`reduce`** 动作。
    *   **例子**: 在项目集 `Iᵢ` 中，**同时存在**:
        *   `[A → α∙]` (要求 `reduce A → α`)
        *   `[B → β∙]` (要求 `reduce B → β`)
    *   **分析器的困惑**: 当我处于状态 `i` 时，我应该把栈顶的东西看作是 `α` 并规约为 `A` 呢？还是应该看作是 `β` 并规约为 `B` 呢？

**只要一个文法在构造 LR(0) 分析表时出现了任何冲突，它就不是一个 LR(0) 文法。** 事实上，只有非常一小部分简单的文法是 LR(0) 的。

---
#### **3.3.3 SLR(1) 的解决方案：引入 FOLLOW 集**

SLR(1) 的全称是 **Simple LR(1)**。它的“Simple”之处在于，它使用了与 LR(0) **完全相同的项目集族和 DFA**，但它在**填表**时，做了一个简单而聪明的改进。

**SLR(1) 的核心思想**:
> **LR(0) 的规约动作太“暴力”了！** 它不管三七二十一，看到规约项目就想对所有输入都进行规约。
>
> **一个更聪明的做法是**：只有当**下一个输入符号 `a`**，确实是一个可以**合法地跟在**非终结符 `A` 后面的符号时，我们才应该执行 `A → β` 这个规约动作。
>
> 哪个集合告诉我们 `A` 后面可以合法地跟什么？—— **FOLLOW(A) 集！**

**SLR(1) 分析表的构造算法**：

1.  构造文法的 **LR(0) 项目集规范族** `{I₀, I₁, ..., Iₙ}`。(这一步和 LR(0) **完全一样**)
2.  计算文法中**所有非终结符的 FOLLOW 集**。
3.  **ACTION 表的填写**:
    *   **移入 (Shift)**: **规则和 LR(0) 完全一样**。
        *   `[A → α∙aβ]` in `Iᵢ` and `goto(Iᵢ, a) = Iⱼ` => `ACTION[i, a] = shift j`
    *   **规约 (Reduce)**: **【这里是唯一的区别！】**
        *   `[A → β∙]` in `Iᵢ` (`A ≠ S'`)
        *   **对于 `FOLLOW(A)` 中的<u>每一个</u>终结符 `a`**，在 `ACTION[i, a]` 处填入 **`reduce A → β`**。
    *   **接受 (Accept)**: **规则和 LR(0) 完全一样**。
        *   `[S' → S∙]` in `Iᵢ` => `ACTION[i, $] = accept`
4.  **GOTO 表的填写**: **规则和 LR(0) 完全一样**。

**SLR(1) 如何解决冲突？**
*   通过只在 `FOLLOW(A)` 对应的列填入 `reduce` 动作，SLR(1) 极大地**减少了** `reduce` 动作的填入范围。
*   这使得很多原来在 LR(0) 中会产生冲突的单元格，现在可能只有一个 `shift` 动作，或者干脆是空的，从而**消解了冲突**。

**如果一个文法在构造 SLR(1) 分析表时，没有产生任何冲突，那么它就是一个 SLR(1) 文法。** SLR(1) 能处理的文法范围远大于 LR(0)，大多数无二义性的表达式文法都是 SLR(1) 的。

---
你这个问题提得**极其深刻**，而且正好点出了从 LR(0) 到 SLR(1) 乃至 LR(1) 的**核心进化动机**。

你完全正确，SLR(1)、LR(1)、LALR(1) 的**唯一目的**，就是为了更精确地回答这一个问题：
> **“在当前这个状态下，我看到了规约项目 `[A → β∙]`，那么，我到底应不应该执行规约？”**

它们之间的区别，就在于回答这个问题时，所使用的“**证据**”的**精确度**不同。

---
### **补充六：冲突的本质与解决策略的演进**

让我们用一个法庭审判的例子来比喻。

*   **状态 `I`**: 代表案发现场。
*   **栈顶的内容**: 代表已经收集到的、指向嫌疑人 `β` 的证据。
*   **规约项目 `[A → β∙]`**: 侦探提出一个**假设**：“我认为这些证据 `β` 已经足够充分，可以把它们‘规约’成一个结论 `A`（比如 `β` 是作案动机，`A` 是‘有预谋作案’）”。
*   **移入项目 `[C → α∙aδ]`**: 侦探同时提出另一个假设：“我认为证据还不够，我们需要继续‘移入’下一个证物 `a`，来证明一个更大的结论 `C`”。
*   **下一个输入 `a`**: 代表一个**新的、刚刚出现的证物**。

#### **LR(0) 的决策方式：“一刀切”**

*   **LR(0) 侦探的逻辑**: “只要我能提出‘可以规约’的假设 (`[A → β∙]`)，我就不管三七二十一，**在任何新证物面前**，我都坚持要立刻下结论（规约）！”
*   **问题**: 如果新证物 `a` 恰好是证明另一个更大假设所必需的关键证据（对应移入项目），那么 LR(0) 侦探的武断就会导致**移入-规约冲突**。

#### **SLR(1) 的决策方式：“全局不在场证明”**

*   **SLR(1) 侦探的逻辑**: “我虽然提出了‘可以规约 `A`’的假设，但我会更谨慎一点。我会先查一下‘全局档案’(`FOLLOW(A)`)。这份档案记录了结论 `A` 在**所有可能案件**中，后面都可能跟着哪些证物。”
*   **决策**:
    *   “如果新证物 `a` **在**这份‘全局档案’里，说明在某些案件里 `a` 确实可以跟在 `A` 后面。那么，我现在就规约，是合理的。”
    *   “如果新证物 `a` **不在**这份‘全局档案’里，说明在任何情况下 `A` 后面都不可能跟着 `a`。那么，我当前的规约假设一定是错的，或者输入本身就是错的。此时我不应该规约。”
*   **如何避免冲突**:
    *   在一个状态 `I` 中，如果同时有移入项目 `[C → α∙aδ]` 和规约项目 `[A → β∙]`。
    *   LR(0) 会在 `a` 这一列产生冲突。
    *   SLR(1) 会去检查 `a` 是否在 `FOLLOW(A)` 中。
        *   **如果不在**: `ACTION[I, a]` 就只有 `shift`，没有 `reduce`。**冲突解决！**
        *   **如果在**: `ACTION[I, a]` 依然有 `shift` 和 `reduce`。**冲突依然存在！**

---
#### **做题方法：如何证明一个文法是 SLR(1) 但不是 LR(0)？**

这是一个非常经典的题型。你需要分三步走。

**题目**: 证明文法 G 是 SLR(1) 的，但不是 LR(0) 的。

**步骤**:

1.  **证明它不是 LR(0) 的**:
    *   **方法**: 构造文法 G 的 **LR(0) 项目集族 DFA**。
    *   **寻找证据**: 在构造过程中，找到**至少一个**项目集（状态）`I`，它同时满足以下两种情况之一：
        *   **移入-规约冲突**: `I` 中既有 `[A → α∙aβ]`，又有 `[B → γ∙]`。
        *   **规约-规约冲突**: `I` 中既有 `[A → α∙]`，又有 `[B → β∙]`。
    *   **论证**: “因为在状态 `I` 中，存在 xxx 冲突，所以根据 LR(0) 分析表的构造方法，在 `ACTION[I, a]`（或所有列）中会产生多重定义。因此，该文法不是 LR(0) 文法。”

2.  **证明它是 SLR(1) 的**:
    *   **方法**: 利用上一步构造好的 LR(0) 项目集族，并计算所有非终结符的 **FOLLOW 集**。
    *   **解决冲突**: 回到你在上一步找到的那个（或所有）冲突状态 `I`，用 SLR(1) 的规则来重新判断。
        *   **对于移入-规约冲突 `[A → α∙aβ]` vs `[B → γ∙]`**:
            *   **检查**: 符号 `a` 是否在 `FOLLOW(B)` 中？
            *   **论证**:
                *   如果 **`a ∉ FOLLOW(B)`** (a 不在 B 的 FOLLOW 集中)，那么在 `ACTION[I, a]` 这一格，`shift` 动作保留，但 `reduce` 动作**不会被填入**。因此，冲突消失了。
                *   你需要对所有冲突点都进行这样的分析。
        *   **对于规约-规约冲突 `[A → α∙]` vs `[B → β∙]`**:
            *   **检查**: `FOLLOW(A)` 和 `FOLLOW(B)` 的交集是否为空 (`FOLLOW(A) ∩ FOLLOW(B) = ∅`)？
            *   **论证**:
                *   如果交集为空，那么对于任何一个终结符 `t`，它最多只会出现在 `FOLLOW(A)` 或 `FOLLOW(B)` 中的一个。因此，在 `ACTION[I, t]` 这一格，最多只会填入一个 `reduce` 动作。冲突消失了。
    *   **最终结论**: “因为 G 的 LR(0) 项目集族中所有的冲突，都可以通过 SLR(1) 的规则（即检查 FOLLOW 集）得以解决，构造出的 SLR(1) 分析表中没有任何多重定义项。因此，该文法是 SLR(1) 文法。”

3.  **总结**: “综上所述，文法 G 不是 LR(0) 的，但是 SLR(1) 的。”

---
**一个简单的例子来走一遍流程**

*   **文法 G**:
    1. `S → A a`
    2. `S → b A c`
    3. `S → d c`
    4. `S → b d a`
    5. `A → d`
*   （这是一个构造出来的例子，不一定有实际意义）
*   假设在构造项目集时，我们找到了一个状态 `I`：
    `I = { [A → d∙], [S → d∙c] }`

**证明过程**:
1.  **证明非 LR(0)**:
    *   在状态 `I` 中，存在规约项目 `[A → d∙]` 和移入项目 `[S → d∙c]`。
    *   根据 LR(0) 规则，`ACTION[I, c]` 既要填入 `reduce A→d`，又要填入 `shift j` (假设 `goto(I, c)` 到状态 `j`)。
    *   存在**移入-规约冲突**，因此文法 G 不是 LR(0) 的。

2.  **证明是 SLR(1)**:
    *   计算 `FOLLOW(A)`。
    *   在产生式 `S → Aa` 中，`A` 后面是 `a`。所以 `a ∈ FOLLOW(A)`。
    *   在产生式 `S → bAc` 中，`A` 后面是 `c`。所以 `c ∈ FOLLOW(A)`。
    *   因此，`FOLLOW(A) = {a, c}`。
    *   现在回到冲突状态 `I`。我们用 SLR(1) 规则来填表：
        *   对于移入项目 `[S → d∙c]`，`ACTION[I, c]` 填入 `shift j`。
        *   对于规约项目 `[A → d∙]`，我们只在 `FOLLOW(A)` 对应的列填入规约动作。
        *   `ACTION[I, a]` 填入 `reduce A→d`。
        *   `ACTION[I, c]` 填入 `reduce A→d`。
    *   **再次检查 `ACTION[I, c]`**: 它现在被同时填入了 `shift j` 和 `reduce A→d`！
    *   **结论**: 这个例子中的冲突，**即使是 SLR(1) 也无法解决**！这个文法**不是 SLR(1) 文法**。
    *   （这就引出了我们下一讲的内容：为什么 `FOLLOW` 集有时候也不够精确，以及 LR(1) 是如何解决这个问题的）。

这个例子正好说明了，证明的过程就是**构造 -> 找冲突 -> 尝试用更强的规则解决冲突 -> 得出结论**。

---


