
---

### 第一讲：自下而上分析的核心思想 —— “搭积木”

#### 1.1 核心动作：移入-规约 (Shift-Reduce)

自下而上分析器的工作过程，可以用一个非常简单的循环来描述，这个循环只包含两种基本动作：

1.  **移入 (Shift)**：
    *   **动作**：将输入队列的**第一个** Token，移动到**分析栈**的顶部。
    *   **比喻**：从零件盒里，拿一个最基本的乐高积木，放到你的工作台上。

2.  **规约 (Reduce)**：
    *   **动作**：当分析栈顶部的**一串符号**，正好匹配了某个产生式规则的**右部**时，就将这串符号从栈中**弹出**，然后将该规则的**左部非终结符**压入栈中。
    *   **比喻**：你发现工作台上的几块积木（比如：轮胎、轮毂、车轴），正好可以拼成一个“车轮”部件。于是你把这些零散积木拿走，换上一个已经组装好的“车轮”部件。你完成了一次**抽象**。

**整个分析过程**，就是在这两种动作之间不断抉择，直到最终栈里只剩下开始符号 `S`，并且输入也被耗尽，此时分析成功。

---
#### 1.2 核心概念：规约 (Reduction)

**规约，就是推导的“逆过程”。**

*   **推导 (Derivation)**：`E ⇒ E + T` (把 `E` 展开成 `E+T`)
*   **规约 (Reduction)**：`E + T ⇒ E` (把 `E+T` 归结为 `E`)

**自下而上分析，本质上就是一个不断寻找“可规约子串”并进行规约的过程。**

**例子**:
*   **文法**: `S → aABe`, `A → Abc | b`, `B → d`
*   **输入**: `abcbde`
*   **一个可能的规约序列**:
    `abcbde`
    `aAbcde`  (将 `b` 规约为 `A`)
    `aAde`    (将 `Abc` 规约为 `A`)
    `aABe`    (将 `d` 规约为 `B`)
    `S`       (将 `aABe` 规约为 `S`) -> **分析成功！**

**但是，新的问题来了：在每一步，我们怎么知道应该规约哪一部分呢？**
*   在 `abcbde` 中，第一个 `b` 是一个合法的可规约项。
*   在 `aAbcde` 中，`Abc` 是一个合法的可规约项。

这个“在当前这一步，最应该被规约的子串”，有一个专门的名字，叫做**句柄 (Handle)**。

**什么是句柄？**
> **句柄是<u>最右推导</u>的逆过程。** 在一个句型中，句柄是与某个产生式右部匹配的子串，将它规约为该产生式的左部非终结符，可以得到上一步的最右句型。

**简单理解**：句柄就是“**正确的、不会导致我们走入死胡同的**”那个可规约子串。自下而上分析的**全部挑战**，就在于如何**准确地找到句柄**。

---
#### 1.3 终极目标：规范规约 (Canonical Reduction)

一个最完美的自下而上分析过程，就是**规范规约**。它指的是，分析的每一步都是**最右推导的精确逆过程**。

*   **最右推导**: `S ⇒ ... ⇒ γAδ ⇒ γαβδ` (其中 `A → αβ` 是最后一步用的规则)
*   **规范规约**: `γαβδ ⇒ γAδ`

这个 `αβ` 就是 `γαβδ` 的句柄。

**寻找句柄的挑战**:
*   我们怎么知道 `abcbde` 的句柄是第一个 `b`，而不是第二个 `b`？
*   我们怎么知道 `aAbcde` 的句柄是 `Abc`，而不是 `b`？

不同的分析方法，提供了不同的寻找句柄的策略：
*   **算符优先分析法**：通过比较运算符之间的优先级来“框定”句柄的边界。
*   **LR 分析法**：通过一个强大的 DFA（状态机）来精确地识别句柄的出现，并决定何时进行规约。这是最通用、最准确的方法。

---
#### 1.4 工作台：符号栈

为了实现“移入-规约”这个过程，并有效地追踪我们已经“拼好”的部件，我们需要一个**符号栈**。

**工作流程**:
1.  **初始状态**: 栈为空，输入指针指向第一个 Token。
2.  **循环**:
    a.  **决策**: 分析器根据当前**栈顶的状态**和**下一个输入 Token**，来决定是“移入”还是“规约”。（决策的依据，就是不同分析方法的核心，比如 LR 分析表）。
    b.  **执行“移入”**: 从输入队列拿一个 Token，压入栈顶。
    c.  **执行“规约”**:
        i.  在栈顶找到句柄（比如 `αβ`）。
        ii. 把它从栈顶弹出。
        iii. 把对应的产生式左部非终结符 `A` 压入栈顶。
3.  **结束**:
    *   **成功**: 当栈里只剩下开始符号 `S`，且输入队列为空时，分析成功。
    *   **失败**: 如果在某个决策点，分析器发现既不能移入，也不能规约，则报告语法错误。

---
### 第二讲：算符优先分析 —— 一个简单的“热身”

#### 2.1 适用范围：算符文法 (Operator Grammar)

算符优先分析法并**不能**用于所有的文法，它对文法有特殊的要求，这种文法被称为**算符文法**。

**算符文法的定义**：
一个文法是算符文法，如果它**不包含**以下两种形式的产生式：
1.  **右部有两个相邻的非终结符**。例如 `A → BC` 是**不允许**的。
2.  **右部为空** (`ε`)。例如 `A → ε` 是**不允许**的。

**为什么有这个限制？**
*   因为这种分析方法的核心，就是比较**终结符（操作符）**之间的优先关系。
*   如果两个非终结符 `B` 和 `C` 挨在一起，它们之间没有终结符，分析器就不知道该比较谁和谁的优先级了，方法失效。
*   `ε` 的存在会使句柄的边界变得模糊，因此也不允许。

**例子**:
*   `E → E + T | T`  => **是**算符文法 (非终结符 `E`, `T` 被终结符 `+` 分隔)。
*   `S → SS`        => **不是**算符文法 (两个 `S` 相邻)。
*   `A → aB | ε`      => **不是**算符文法 (有 `ε` 产生式)。

---
#### 2.2 核心工具：算符优先关系

算符优先分析法的“大脑”，就是一张**任意两个终结符之间的优先关系表**。

**三种优先关系** (设 `t₁` 和 `t₂` 是两个终结符)：

1.  **`t₁ ∙> t₂` (t₁ 的优先级高于 t₂) **
    *   **含义**: 当分析器在栈里看到 `t₁`，而下一个输入是 `t₂` 时，这强烈暗示着，以 `t₁` 为结尾的**句柄**已经在栈顶形成了，是时候进行**规约**了。
    *   **例子**: `id * id + id`。当看到 `*` 和 `+` 时，我们知道 `*` 的优先级高，所以 `id*id` 这部分应该先被规约。

2.  **`t₁ <∙ t₂` (t₁ 的优先级低于 t₂) **
    *   **含义**: 当栈顶附近是 `t₁`，而输入是 `t₂` 时，这暗示着句柄还没有形成，`t₂` 应该被**移入**栈中，继续向后看。
    *   **例子**: `id + id * id`。看到 `+` 和 `*` 时，`+` 优先级低，所以 `*` 和后面的 `id` 应该先被移入栈，等待形成更高优先级的 `id*id`。

3.  **`t₁ ∙= t₂` (t₁ 的优先级等于 t₂) **
    *   **含义**: `t₁` 和 `t₂` 属于同一个句柄的一部分。
    *   **例子**: `( E )`。 `(` 和 `)` 优先级相等，它们共同“包裹”了一个表达式。

**如何系统地构造优先关系表？**

这需要两个辅助集合，它们只针对**非终结符**计算：

*   **`FIRSTVT(P)`**: 非终结符 `P` 能推导出的、所有字符串**开头**的那个**终结符**的集合。
    *   (VT = Vocabulary of Terminals)
*   **`LASTVT(P)`**: 非终结符 `P` 能推导出的、所有字符串**结尾**的那个**终结符**的集合。

**构造规则 (遍历所有产生式)**：

1.  对于形如 `... t₁ t₂ ...` 或 `... t₁ P ...` 且 `t₂ ∈ FIRSTVT(P)` 的产生式右部：
    *   建立关系 **`t₁ <∙ t₂`**。
2.  对于形如 `... P t₁ ...` 且 `t₂ ∈ LASTVT(P)` 的产生式右部：
    *   建立关系 **`t₂ ∙> t₁`**。
3.  对于形如 `... t₁ t₂ ...` 或 `... t₁ P t₂ ...` 的产生式右部：
    *   建立关系 **`t₁ ∙= t₂`**。

---
#### 2.3 算符优先分析算法

这个算法非常直观，它使用一个符号栈，不断地比较“**栈顶的第一个终结符**”和“**当前输入符号**”之间的优先关系。

**算法流程**:
1.  在符号栈底和输入串末尾都加上一个特殊的低优先级界符 `$`。
2.  **循环**:
    a.  设 `a` 是栈顶的第一个终结符，`b` 是当前输入符号。
    b.  **`if a <∙ b` 或 `a ∙= b`**:
        *   **移入 (Shift)**。将 `b` 压入栈，输入指针后移。
    c.  **`else if a ∙> b`**:
        *   **规约 (Reduce)**。从栈顶向左，找到最左边的那个 `<∙` 关系，之间的所有内容就是句柄。
        *   对这个句柄执行一次（盲目的）规约，即将它替换成一个通用的非终结符（比如 `N`）。
        *   **注意**: 算符优先分析**不关心**具体用哪条产生式规约，它只关心句柄的**边界**。
    d.  **`else`**:
        *   **出错**。
3.  **结束**: 当栈中只剩下 `$ N $` (或 `$S$`) 时，分析成功。

---
#### 2.4 优缺点总结

*   **优点**:
    1.  **实现简单**: 算法逻辑直观，核心就是查表和比较，很容易手动实现。
    2.  **效率高**: 分析过程是线性的。
    3.  **擅长处理表达式**: 对于以中缀表示的算术表达式和逻辑表达式，这种方法非常有效。

*   **缺点**:
    1.  **能分析的文法有限**: 必须是算符文法，这排除了很多常见的语法结构。
    2.  **“假装”规约**: 它只能找到句柄的边界，但**无法确定**应该用哪一条产生式进行规约。因此，它**不能**用于构造详细的语法树，通常只能得到一个运算符的执行序列。
    3.  **错误处理能力弱**: 发现错误后，恢复起来比较困难。

---
