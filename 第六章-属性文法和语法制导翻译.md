
---
### **第一讲：概述与属性文法 —— 让语法树开口说话**

#### **1. 新的挑战：超越“语法正确”**

到目前为止，我们学习的语法分析器（无论是 LL 还是 LR）都非常强大，但它们只能回答一个问题：

> **“这个句子的<u>结构</u>对不对？”**

它们能告诉你 `int x = 5;` 的结构是正确的，但对于 `int x = "hello";`，它们可能也认为结构是正确的（`类型 标识符 = 字面量 ;`）。

语法分析器无法回答更深层次的“**含义**”问题：
*   **类型是否匹配？** (不能把字符串赋给整型变量)
*   **变量是否已声明？** (使用 `y = x;` 之前，`x` 声明了吗？)
*   **函数调用的参数数量/类型是否正确？**

这些都属于**静态语义 (Static Semantics)** 的范畴。**语法制导翻译 (Syntax-Directed Translation)** 就是一套**在语法分析的同时，进行静态语义检查和（或）生成中间代码**的形式化框架。

---
#### **2. 核心思想：在语法树上“流动”的信息**

语法制导翻译的核心思想非常优雅：

> **我们可以在<u>语法树</u>的节点之间，<u>传递</u>和<u>计算</u>各种“信息”。**
>
> **我们把这些“信息”称为<u>属性 (Attributes)</u>。**
>
> **计算这些“信息”的规则，与文法的产生式<u>绑定</u>在一起，称为<u>语义规则 (Semantic Rules)</u>。**

**一个简单的比喻：家族谱系**

*   **语法树**: 就像一个家族的族谱树。
*   **属性**: 就像每个家庭成员的信息，比如“姓名”、“出生年份”、“财富”。
*   **语义规则**: 就像家族的规定，比如：
    *   “孩子的姓氏，**继承自**父亲的姓氏。” (信息从上向下流动)
    *   “家庭的总财富，是父亲的财富**加上**所有孩子财富的总和。” (信息从下向上传递)

通过在族谱树上应用这些规则，我们就能计算出每个人的完整信息和每个家庭的状况。

---
### **1. 属性文法 (Attribute Grammar)：形式化的定义**

**属性文法**，就是对上面思想的一个形式化定义。它是在**上下文无关文法 (CFG)** 的基础上，增加了两样东西：

1.  **属性 (Attributes)**:
    *   每个文法符号（终结符或非终结符）都可以关联一个或多个属性。
    *   **例子**:
        *   非终结符 `E` (表达式) 可能有一个属性 `E.val`，代表表达式的计算值。
        *   终结符 `id` (标识符) 可能有一个属性 `id.name`，代表标识符的字符串名字。
        *   非终结符 `T` (类型) 可能有一个属性 `T.type`，代表是 `int` 还是 `float`。

2.  **语义规则 (Semantic Rules)**:
    *   每一条**产生式**，都附带一组语义规则。
    *   这些规则定义了如何计算该产生式中，涉及的文法符号的属性值。
    *   规则只能使用产生式中**已有的**符号的属性值。

**例子**:
*   **产生式**: `E → E₁ + T`
*   **语义规则**: `{ E.val = E₁.val + T.val }`
    *   这条规则说：父节点 `E` 的 `val` 属性值，等于其子节点 `E₁` 和 `T` 的 `val` 属性值的和。

---
#### **1.1 两类属性：综合属性 vs. 继承属性**

属性的信息“流动方向”决定了它的类型，这是整个属性文法理论的**核心**。

**1. 综合属性 (Synthesized Attributes)**

*   **流动方向**: **自下而上 (Bottom-Up)**。
*   **定义**: 一个节点的**综合属性**值，是由其**子节点**的属性值计算出来的。
*   **比喻**: 孩子们的成就（子节点属性），“**综合**”成了父母的骄傲（父节点属性）。
*   **例子**: `E → E₁ + T { E.val = E₁.val + T.val }`
    *   `E.val` 是一个综合属性，因为它依赖于子节点 `E₁` 和 `T` 的属性。
    *   终结符的属性（比如词法分析器提供的值）可以看作是“初始的”综合属性。

**2. 继承属性 (Inherited Attributes)**

*   **流动方向**: **自上而下 (Top-Down)**。
*   **定义**: 一个节点的**继承属性**值，是由其**父节点**或**兄弟节点**的属性值计算出来的。
*   **比喻**: 父母的姓氏（父节点属性），“**继承**”给了孩子（子节点属性）。
*   **例子**: C语言变量声明 `D → T L` (D:声明, T:类型, L:变量列表)
    *   **产生式**: `L → L₁, id`
    *   **语义规则**: `{ L₁.in_type = L.in_type; add_type(id.entry, L.in_type) }`
    *   这里，`L` 从父节点 `D` 那里“继承”了一个类型 `in_type`。然后，它把这个 `in_type` 属性继续“传递”给它的兄弟节点 `L₁`，并用它来更新符号表。
    *   `L.in_type` 和 `L₁.in_type` 就是继承属性。

---
