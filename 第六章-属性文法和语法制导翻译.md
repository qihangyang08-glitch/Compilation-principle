
---
### **第一讲：概述与属性文法 —— 让语法树开口说话**

#### **1. 新的挑战：超越“语法正确”**

到目前为止，我们学习的语法分析器（无论是 LL 还是 LR）都非常强大，但它们只能回答一个问题：

> **“这个句子的<u>结构</u>对不对？”**

它们能告诉你 `int x = 5;` 的结构是正确的，但对于 `int x = "hello";`，它们可能也认为结构是正确的（`类型 标识符 = 字面量 ;`）。

语法分析器无法回答更深层次的“**含义**”问题：
*   **类型是否匹配？** (不能把字符串赋给整型变量)
*   **变量是否已声明？** (使用 `y = x;` 之前，`x` 声明了吗？)
*   **函数调用的参数数量/类型是否正确？**

这些都属于**静态语义 (Static Semantics)** 的范畴。**语法制导翻译 (Syntax-Directed Translation)** 就是一套**在语法分析的同时，进行静态语义检查和（或）生成中间代码**的形式化框架。

---
#### **2. 核心思想：在语法树上“流动”的信息**

语法制导翻译的核心思想非常优雅：

> **我们可以在<u>语法树</u>的节点之间，<u>传递</u>和<u>计算</u>各种“信息”。**
>
> **我们把这些“信息”称为<u>属性 (Attributes)</u>。**
>
> **计算这些“信息”的规则，与文法的产生式<u>绑定</u>在一起，称为<u>语义规则 (Semantic Rules)</u>。**

**一个简单的比喻：家族谱系**

*   **语法树**: 就像一个家族的族谱树。
*   **属性**: 就像每个家庭成员的信息，比如“姓名”、“出生年份”、“财富”。
*   **语义规则**: 就像家族的规定，比如：
    *   “孩子的姓氏，**继承自**父亲的姓氏。” (信息从上向下流动)
    *   “家庭的总财富，是父亲的财富**加上**所有孩子财富的总和。” (信息从下向上传递)

通过在族谱树上应用这些规则，我们就能计算出每个人的完整信息和每个家庭的状况。

---
### **1. 属性文法 (Attribute Grammar)：形式化的定义**

**属性文法**，就是对上面思想的一个形式化定义。它是在**上下文无关文法 (CFG)** 的基础上，增加了两样东西：

1.  **属性 (Attributes)**:
    *   每个文法符号（终结符或非终结符）都可以关联一个或多个属性。
    *   **例子**:
        *   非终结符 `E` (表达式) 可能有一个属性 `E.val`，代表表达式的计算值。
        *   终结符 `id` (标识符) 可能有一个属性 `id.name`，代表标识符的字符串名字。
        *   非终结符 `T` (类型) 可能有一个属性 `T.type`，代表是 `int` 还是 `float`。

2.  **语义规则 (Semantic Rules)**:
    *   每一条**产生式**，都附带一组语义规则。
    *   这些规则定义了如何计算该产生式中，涉及的文法符号的属性值。
    *   规则只能使用产生式中**已有的**符号的属性值。

**例子**:
*   **产生式**: `E → E₁ + T`
*   **语义规则**: `{ E.val = E₁.val + T.val }`
    *   这条规则说：父节点 `E` 的 `val` 属性值，等于其子节点 `E₁` 和 `T` 的 `val` 属性值的和。

---
#### **1.1 两类属性：综合属性 vs. 继承属性**


**核心问题**: 在语法分析过程中，我们需要计算各种语义信息（比如一个表达式的值，一个变量的类型）。这些信息从哪里来，又流向哪里去？

**答案**: 信息在语法树上，只有两种基本的流动方向：**向上**或**向下/向旁**。这两种流动方向，就定义了两种根本不同的属性类型。

---
#### **1. 综合属性 (Synthesized Attributes) —— “汇总报告”**

*   **流动方向**: **自下而上 (Bottom-Up)**。信息从子节点流向父节点。
*   **定义**: 一个语法节点 `N` 的**综合属性**，其值是由 `N` 的**子节点**的属性值，或者 `N` 自身的一些内在属性（比如一个数字字面量的值）来计算的。
*   **直观理解**: 综合属性就像是在“**向上汇报工作**”或“**汇总结果**”。每个节点都在总结它的孩子们的信息，然后把总结报告交给自己的父节点。

*   **最经典的例子：表达式求值**
    *   **文法**: `E → E₁ + T`
    *   **语义规则**: `{ E.val = E₁.val + T.val }`
    *   **分析**:
        *   要计算 `E.val`，你**必须**先知道它的两个子节点 `E₁.val` 和 `T.val` 的值。
        *   信息流是 `E₁.val` → `E.val` 且 `T.val` → `E.val`。
        *   这是一种典型的**自下而上**的信息汇总。所以 `val` 是一个综合属性。

*   **另一个例子：语法树构建**
    *   **文法**: `E → E₁ + T`
    *   **语义规则**: `{ E.node_ptr = make_node('+', E₁.node_ptr, T.node_ptr) }`
    *   **分析**:
        *   要构建 `E` 对应的这个 `+` 节点，你**必须**先拥有它的左右子树的指针 `E₁.node_ptr` 和 `T.node_ptr`。
        *   信息（子树指针）也是**从下向上传递**来构建一棵更大的树。所以 `node_ptr` 也是一个综合属性。

**一句话总结综合属性**: **它的值由“下面”决定。**

---
#### **2. 继承属性 (Inherited Attributes) —— “指令下达”**

*   **流动方向**: **自上而下 (Top-Down)** 或 **从左到右 (Sideways)**。信息从父节点或兄弟节点流向子节点。
*   **定义**: 一个语法节点 `X` 的**继承属性**，其值是由 `X` 的**父节点**或 `X` 的**兄弟节点**的属性值来计算的。
*   **直观理解**: 继承属性就像是在“**向下传达指令**”或“**获取上下文信息**”。父节点把自己掌握的环境信息，传递给子节点，以便子节点能正确地完成自己的工作。

*   **最经典的例子：变量类型声明**
    *   **文法**: `D → T L` (D:声明, T:类型, L:变量列表)
    *   **语义规则**: `{ L.in_type = T.type }`
    *   **分析**:
        *   `L` (变量列表，比如 `x,y,z`) 本身并不知道自己是什么类型。这个“类型”信息必须从它的**兄弟节点** `T` (比如 `int`) 那里获得。
        *   信息流是 `T.type` → `L.in_type`。这是一个**从左到右**的“兄弟传信”。
    *   **再看 `L` 的展开**:
        *   **文法**: `L → id`
        *   **语义规则**: `{ add_symbol_type(id.name, L.in_type) }`
        *   **分析**:
            *   为了给符号表里的 `id` 登记正确的类型，`id` 节点需要知道这个类型是什么。
            *   这个类型信息 `L.in_type` 是从它的**父节点** `L` 那里“继承”来的。
            *   信息流是 `L.in_type` (父) → `L.in_type` (子，用于规则)。这是一个典型的**自上而下**的“指令下达”。
    *   所以，`in_type` 是一个继承属性。

**一句话总结继承属性**: **它的值由“上面”或“左边”决定。**

---
#### **3. 为什么需要区分这两种属性？**

**答案：因为它们与编译器的<u>不同工作流程</u>紧密相连。**

1.  **实现方式不同**:
    *   **综合属性**的计算流程，与**自下而上 (Bottom-Up) 语法分析**（如 LR 分析）的**规约 (Reduce)** 动作是**天作之合**。当分析器决定将 `β` 规约为 `A` 时，`β` 中所有符号的属性都已经计算完毕并存在栈里了，此时正是计算 `A` 的综合属性的最佳时机。
    *   **继承属性**的计算流程，与**自上而下 (Top-Down) 语法分析**（如 LL 分析）的**推导 (Expand)** 动作，或者**对语法树的深度优先遍历**是天作之合。当分析器要展开 `A` 时，可以把父节点的上下文信息（继承属性）传递下去。

2.  **文法分类的依据**:
    *   **S-属性文法** (只含综合属性) 和 **L-属性文法** (继承属性只能从左边兄弟获取) 这两种重要的分类，就是**根据属性的类型和流动方向**来定义的。
    *   这些分类决定了我们是否可以在**一次遍历**（或在语法分析的同时）就完成所有属性的计算。

---
#### **4. 如何将继承属性改写为综合属性？**

PPT 提到这一点，是因为纯粹的 S-属性文法（只含综合属性）是最容易在自下而上分析器中实现的。有时候，为了能使用这种简单的实现方式，我们会尝试把一些继承属性“改造”成综合属性。

**这通常是通过修改文法，增加额外的参数或返回值来实现的，但这是一个高级技巧，而且并不总是可行。**

**例子 (概念性)**:
*   **原始 (继承属性)**:
    `A → B C`
    `{ B.in = A.in; C.in = B.out }` (信息从 A->B, B->C)
*   **改写思路**:
    我们修改文法，让 `B` 在推导时，不仅返回自己的结果，还把需要传递给 `C` 的信息也“综合”上来。
*   **可能的一种改写 (非常不直观)**:
    `A → X`
    `X → Y Z` (其中Y代表B，Z代表C，但它们的产生式被重构)
    这个过程会把文法变得非常复杂和不自然，所以它只在特定情况下使用。更常见的做法是，如果一个文法天然地需要继承属性，我们就使用能处理它的 L-属性文法分析方法（比如在生成语法树后，再进行一次树遍历）。

**总结**:
*   **综合属性**: **子->父**，像“汇总报告”。
*   **继承属性**: **父->子** 或 **兄->弟**，像“指令下达”。
*   **区分的目的**: 它们的计算时机和对分析流程的依赖完全不同，是选择和设计语法制导翻译方案的基础。
---

### **第二讲：基于属性文法的处理方法 —— 依赖图与文法分类**
上一讲，我们定义了属性文法的“蓝图”——**综合属性**（自下而上）和**继承属性**（自上而下）。现在，我们面临一个实际的工程问题：

> **对于一棵给定的语法树，我们应该按照什么样的<u>顺序</u>来计算树上各个节点的属性值？**

显然，我们不能随意计算。比如，在计算 `E.val = E₁.val + T.val` 时，必须先得到 `E₁.val` 和 `T.val` 的值。这就引出了“**依赖关系**”的概念。

#### **2.1 依赖图：可视化属性计算顺序**

*   **什么是依赖图 (Dependency Graph)？**
    *   对于一棵**特定的语法树**，我们可以画出一张图，来清晰地表示树中所有属性实例之间的依赖关系。
    *   **图的节点**: 语法树中**每个节点**的**每个属性**，都成为依赖图中的一个节点。
    *   **图的有向边**: 如果属性 `B` 的值依赖于属性 `A` 的值（即计算 `B` 的语义规则中用到了 `A`），那么就画一条从 `A` 到 `B` 的有向边 `A → B`。

*   **例子**: `E → E₁ + T { E.val = E₁.val + T.val }`
    *   依赖图会包含三条边：
        *   `E₁.val → E.val`
        *   `T.val → E.val`

*   **依赖图的作用**:
    *   **合法性检查**: 如果依赖图中存在**环路 (Cycle)**，那么这个属性文法就是**循环定义 (circularly defined)** 的，无法计算。例如 `{ A.x = B.y; B.y = A.x; }`。
    *   **确定计算顺序**: 依赖图是一个 **DAG (有向无环图)**。对这个图进行**拓扑排序 (Topological Sort)**，就能得到一个（或多个）合法的属性计算顺序。

**结论**: 依赖图是一个强大的理论工具，但为每一棵语法树都去构造和排序它，在实践中效率太低。我们需要更通用的、与特定语法树无关的计算策略。

---
#### **2.2 通用计算策略：树遍历**

既然属性是在树上传递的，那么最自然的计算方式就是**遍历语法树**。

*   **自下而上**的综合属性，天然地适合在**后序遍历 (Post-order Traversal)** 中计算。
*   **自上而下**的继承属性，天然地适合在**前序遍历 (Pre-order Traversal)** 或其他深度优先遍历中计算。

当两种属性混合时，情况就变得复杂，可能需要多次遍历或者更复杂的遍历策略。为了简化实现，并与我们学过的语法分析方法相结合，人们定义了两类**行为良好**的属性文法。

---
### **文法分类：S-属性文法 与 L-属性文法**

这两类文法，是对属性文法施加的**限制**，目的是让属性计算能够**更容易地**与特定的语法分析过程（自下而上或自上而下）相结合。

#### **2.3 S-属性文法 (S-Attributed Grammar)**

*   **S 的含义**: **Synthesized** (综合的)。
*   **定义**: 一个属性文法是 S-属性文法，如果它**只使用综合属性**。
*   **这是一个非常严格但简单的限制。**

*   **为什么需要它？—— 完美契合自下而上分析**
    *   我们回忆一下**自下而上 (Bottom-Up) 分析**（如 LR 分析）的过程：它先识别出子节点，然后将它们**规约 (Reduce)** 成父节点。
    *   这个“**先子后父**”的过程，与综合属性“**由子节点计算父节点**”的**自下而上**信息流，是**完全同构**的！
    *   **实现**: 我们可以在 LR 分析的**规约**动作发生时，立即执行相应的语义规则，计算出父节点的综合属性值。
    *   **例如**: 当分析器将 `E₁ + T` 规约为 `E` 时，`E₁.val` 和 `T.val` 的值（它们在分析栈的对应位置）已经是已知的了，此时可以立即计算 `E.val`。

*   **结论**: S-属性文法非常简单，可以**在 LR 分析过程中，一次性地、自下而上地**完成所有属性的计算。

#### **2.4 L-属性文法 (L-Attributed Grammar)**

*   **L 的含义**: **Left-to-right** (从左到右)。
*   **定义**: 这个定义更宽松，也更复杂。一个属性文法是 L-属性文法，如果对于它的**每一个**产生式 `A → X₁ X₂ ... Xₙ`，其附带的每一条语义规则（用于计算 `Xᵢ` 的某个**继承属性**），都**只依赖于**:
    1.  `A` 的**继承属性** (父传子)。
    2.  `Xᵢ` **左边**的兄弟节点 `X₁, ..., Xᵢ₋₁` 的**任意**属性 (左传右)。

*   **禁止的行为**: L-属性文法**禁止**一个属性依赖于它**右边**的兄弟节点的任何属性。

*   **直观理解**: L-属性文法允许的信息流是**严格从上到下、从左到右**的。

*   **为什么需要它？—— 契合自上而下和深度优先遍历**
    *   **自上而下 (Top-Down) 分析** (如 LL 分析) 的过程，本身就是一种从左到右的深度优先展开。
    *   当分析器处理到 `Xᵢ` 时，`A` 的继承属性（从上层传来）是已知的，`X₁` 到 `Xᵢ₋₁`（在 `Xᵢ` 左边）也已经被处理完毕，它们的属性值都是已知的。
    *   因此，`Xᵢ` 的继承属性所需要的所有信息，在处理到它的时候**恰好都已经准备好了**。
    *   **实现**: 可以在**深度优先遍历 (Depth-First Traversal)** 语法树的过程中，一次性地计算出所有属性。对于 LL 分析器，可以在推导过程中实时计算；对于 LR 分析器，则需要在生成语法树后，再进行一次从左到右的深度优先遍历来计算。

**重要关系**:
> **所有的 S-属性文法，也都是 L-属性文法。**
>
> (因为 S-属性文法根本没有继承属性，自然不会违反 L-属性文法的任何限制。)

---

