
---
### **第一讲：概述与属性文法 —— 让语法树开口说话**

#### **1. 新的挑战：超越“语法正确”**

到目前为止，我们学习的语法分析器（无论是 LL 还是 LR）都非常强大，但它们只能回答一个问题：

> **“这个句子的<u>结构</u>对不对？”**

它们能告诉你 `int x = 5;` 的结构是正确的，但对于 `int x = "hello";`，它们可能也认为结构是正确的（`类型 标识符 = 字面量 ;`）。

语法分析器无法回答更深层次的“**含义**”问题：
*   **类型是否匹配？** (不能把字符串赋给整型变量)
*   **变量是否已声明？** (使用 `y = x;` 之前，`x` 声明了吗？)
*   **函数调用的参数数量/类型是否正确？**

这些都属于**静态语义 (Static Semantics)** 的范畴。**语法制导翻译 (Syntax-Directed Translation)** 就是一套**在语法分析的同时，进行静态语义检查和（或）生成中间代码**的形式化框架。

---
#### **2. 核心思想：在语法树上“流动”的信息**

语法制导翻译的核心思想非常优雅：

> **我们可以在<u>语法树</u>的节点之间，<u>传递</u>和<u>计算</u>各种“信息”。**
>
> **我们把这些“信息”称为<u>属性 (Attributes)</u>。**
>
> **计算这些“信息”的规则，与文法的产生式<u>绑定</u>在一起，称为<u>语义规则 (Semantic Rules)</u>。**

**一个简单的比喻：家族谱系**

*   **语法树**: 就像一个家族的族谱树。
*   **属性**: 就像每个家庭成员的信息，比如“姓名”、“出生年份”、“财富”。
*   **语义规则**: 就像家族的规定，比如：
    *   “孩子的姓氏，**继承自**父亲的姓氏。” (信息从上向下流动)
    *   “家庭的总财富，是父亲的财富**加上**所有孩子财富的总和。” (信息从下向上传递)

通过在族谱树上应用这些规则，我们就能计算出每个人的完整信息和每个家庭的状况。

---
### **1. 属性文法 (Attribute Grammar)：形式化的定义**

**属性文法**，就是对上面思想的一个形式化定义。它是在**上下文无关文法 (CFG)** 的基础上，增加了两样东西：

1.  **属性 (Attributes)**:
    *   每个文法符号（终结符或非终结符）都可以关联一个或多个属性。
    *   **例子**:
        *   非终结符 `E` (表达式) 可能有一个属性 `E.val`，代表表达式的计算值。
        *   终结符 `id` (标识符) 可能有一个属性 `id.name`，代表标识符的字符串名字。
        *   非终结符 `T` (类型) 可能有一个属性 `T.type`，代表是 `int` 还是 `float`。

2.  **语义规则 (Semantic Rules)**:
    *   每一条**产生式**，都附带一组语义规则。
    *   这些规则定义了如何计算该产生式中，涉及的文法符号的属性值。
    *   规则只能使用产生式中**已有的**符号的属性值。

**例子**:
*   **产生式**: `E → E₁ + T`
*   **语义规则**: `{ E.val = E₁.val + T.val }`
    *   这条规则说：父节点 `E` 的 `val` 属性值，等于其子节点 `E₁` 和 `T` 的 `val` 属性值的和。

---
#### **1.1 两类属性：综合属性 vs. 继承属性**

属性的信息“流动方向”决定了它的类型，这是整个属性文法理论的**核心**。

**1. 综合属性 (Synthesized Attributes)**

*   **流动方向**: **自下而上 (Bottom-Up)**。
*   **定义**: 一个节点的**综合属性**值，是由其**子节点**的属性值计算出来的。
*   **比喻**: 孩子们的成就（子节点属性），“**综合**”成了父母的骄傲（父节点属性）。
*   **例子**: `E → E₁ + T { E.val = E₁.val + T.val }`
    *   `E.val` 是一个综合属性，因为它依赖于子节点 `E₁` 和 `T` 的属性。
    *   终结符的属性（比如词法分析器提供的值）可以看作是“初始的”综合属性。

**2. 继承属性 (Inherited Attributes)**

*   **流动方向**: **自上而下 (Top-Down)**。
*   **定义**: 一个节点的**继承属性**值，是由其**父节点**或**兄弟节点**的属性值计算出来的。
*   **比喻**: 父母的姓氏（父节点属性），“**继承**”给了孩子（子节点属性）。
*   **例子**: C语言变量声明 `D → T L` (D:声明, T:类型, L:变量列表)
    *   **产生式**: `L → L₁, id`
    *   **语义规则**: `{ L₁.in_type = L.in_type; add_type(id.entry, L.in_type) }`
    *   这里，`L` 从父节点 `D` 那里“继承”了一个类型 `in_type`。然后，它把这个 `in_type` 属性继续“传递”给它的兄弟节点 `L₁`，并用它来更新符号表。
    *   `L.in_type` 和 `L₁.in_type` 就是继承属性。

---

### **第二讲：基于属性文法的处理方法 —— 依赖图与文法分类**
上一讲，我们定义了属性文法的“蓝图”——**综合属性**（自下而上）和**继承属性**（自上而下）。现在，我们面临一个实际的工程问题：

> **对于一棵给定的语法树，我们应该按照什么样的<u>顺序</u>来计算树上各个节点的属性值？**

显然，我们不能随意计算。比如，在计算 `E.val = E₁.val + T.val` 时，必须先得到 `E₁.val` 和 `T.val` 的值。这就引出了“**依赖关系**”的概念。

#### **2.1 依赖图：可视化属性计算顺序**

*   **什么是依赖图 (Dependency Graph)？**
    *   对于一棵**特定的语法树**，我们可以画出一张图，来清晰地表示树中所有属性实例之间的依赖关系。
    *   **图的节点**: 语法树中**每个节点**的**每个属性**，都成为依赖图中的一个节点。
    *   **图的有向边**: 如果属性 `B` 的值依赖于属性 `A` 的值（即计算 `B` 的语义规则中用到了 `A`），那么就画一条从 `A` 到 `B` 的有向边 `A → B`。

*   **例子**: `E → E₁ + T { E.val = E₁.val + T.val }`
    *   依赖图会包含三条边：
        *   `E₁.val → E.val`
        *   `T.val → E.val`

*   **依赖图的作用**:
    *   **合法性检查**: 如果依赖图中存在**环路 (Cycle)**，那么这个属性文法就是**循环定义 (circularly defined)** 的，无法计算。例如 `{ A.x = B.y; B.y = A.x; }`。
    *   **确定计算顺序**: 依赖图是一个 **DAG (有向无环图)**。对这个图进行**拓扑排序 (Topological Sort)**，就能得到一个（或多个）合法的属性计算顺序。

**结论**: 依赖图是一个强大的理论工具，但为每一棵语法树都去构造和排序它，在实践中效率太低。我们需要更通用的、与特定语法树无关的计算策略。

---
#### **2.2 通用计算策略：树遍历**

既然属性是在树上传递的，那么最自然的计算方式就是**遍历语法树**。

*   **自下而上**的综合属性，天然地适合在**后序遍历 (Post-order Traversal)** 中计算。
*   **自上而下**的继承属性，天然地适合在**前序遍历 (Pre-order Traversal)** 或其他深度优先遍历中计算。

当两种属性混合时，情况就变得复杂，可能需要多次遍历或者更复杂的遍历策略。为了简化实现，并与我们学过的语法分析方法相结合，人们定义了两类**行为良好**的属性文法。

---
### **文法分类：S-属性文法 与 L-属性文法**

这两类文法，是对属性文法施加的**限制**，目的是让属性计算能够**更容易地**与特定的语法分析过程（自下而上或自上而下）相结合。

#### **2.3 S-属性文法 (S-Attributed Grammar)**

*   **S 的含义**: **Synthesized** (综合的)。
*   **定义**: 一个属性文法是 S-属性文法，如果它**只使用综合属性**。
*   **这是一个非常严格但简单的限制。**

*   **为什么需要它？—— 完美契合自下而上分析**
    *   我们回忆一下**自下而上 (Bottom-Up) 分析**（如 LR 分析）的过程：它先识别出子节点，然后将它们**规约 (Reduce)** 成父节点。
    *   这个“**先子后父**”的过程，与综合属性“**由子节点计算父节点**”的**自下而上**信息流，是**完全同构**的！
    *   **实现**: 我们可以在 LR 分析的**规约**动作发生时，立即执行相应的语义规则，计算出父节点的综合属性值。
    *   **例如**: 当分析器将 `E₁ + T` 规约为 `E` 时，`E₁.val` 和 `T.val` 的值（它们在分析栈的对应位置）已经是已知的了，此时可以立即计算 `E.val`。

*   **结论**: S-属性文法非常简单，可以**在 LR 分析过程中，一次性地、自下而上地**完成所有属性的计算。

#### **2.4 L-属性文法 (L-Attributed Grammar)**

*   **L 的含义**: **Left-to-right** (从左到右)。
*   **定义**: 这个定义更宽松，也更复杂。一个属性文法是 L-属性文法，如果对于它的**每一个**产生式 `A → X₁ X₂ ... Xₙ`，其附带的每一条语义规则（用于计算 `Xᵢ` 的某个**继承属性**），都**只依赖于**:
    1.  `A` 的**继承属性** (父传子)。
    2.  `Xᵢ` **左边**的兄弟节点 `X₁, ..., Xᵢ₋₁` 的**任意**属性 (左传右)。

*   **禁止的行为**: L-属性文法**禁止**一个属性依赖于它**右边**的兄弟节点的任何属性。

*   **直观理解**: L-属性文法允许的信息流是**严格从上到下、从左到右**的。

*   **为什么需要它？—— 契合自上而下和深度优先遍历**
    *   **自上而下 (Top-Down) 分析** (如 LL 分析) 的过程，本身就是一种从左到右的深度优先展开。
    *   当分析器处理到 `Xᵢ` 时，`A` 的继承属性（从上层传来）是已知的，`X₁` 到 `Xᵢ₋₁`（在 `Xᵢ` 左边）也已经被处理完毕，它们的属性值都是已知的。
    *   因此，`Xᵢ` 的继承属性所需要的所有信息，在处理到它的时候**恰好都已经准备好了**。
    *   **实现**: 可以在**深度优先遍历 (Depth-First Traversal)** 语法树的过程中，一次性地计算出所有属性。对于 LL 分析器，可以在推导过程中实时计算；对于 LR 分析器，则需要在生成语法树后，再进行一次从左到右的深度优先遍历来计算。

**重要关系**:
> **所有的 S-属性文法，也都是 L-属性文法。**
>
> (因为 S-属性文法根本没有继承属性，自然不会违反 L-属性文法的任何限制。)

---

