
---
### **第一讲：概述与属性文法 —— 让语法树开口说话**

#### **1. 新的挑战：超越“语法正确”**

到目前为止，我们学习的语法分析器（无论是 LL 还是 LR）都非常强大，但它们只能回答一个问题：

> **“这个句子的<u>结构</u>对不对？”**

它们能告诉你 `int x = 5;` 的结构是正确的，但对于 `int x = "hello";`，它们可能也认为结构是正确的（`类型 标识符 = 字面量 ;`）。

语法分析器无法回答更深层次的“**含义**”问题：
*   **类型是否匹配？** (不能把字符串赋给整型变量)
*   **变量是否已声明？** (使用 `y = x;` 之前，`x` 声明了吗？)
*   **函数调用的参数数量/类型是否正确？**

这些都属于**静态语义 (Static Semantics)** 的范畴。**语法制导翻译 (Syntax-Directed Translation)** 就是一套**在语法分析的同时，进行静态语义检查和（或）生成中间代码**的形式化框架。

---
#### **2. 核心思想：在语法树上“流动”的信息**

语法制导翻译的核心思想非常优雅：

> **我们可以在<u>语法树</u>的节点之间，<u>传递</u>和<u>计算</u>各种“信息”。**
>
> **我们把这些“信息”称为<u>属性 (Attributes)</u>。**
>
> **计算这些“信息”的规则，与文法的产生式<u>绑定</u>在一起，称为<u>语义规则 (Semantic Rules)</u>。**

**一个简单的比喻：家族谱系**

*   **语法树**: 就像一个家族的族谱树。
*   **属性**: 就像每个家庭成员的信息，比如“姓名”、“出生年份”、“财富”。
*   **语义规则**: 就像家族的规定，比如：
    *   “孩子的姓氏，**继承自**父亲的姓氏。” (信息从上向下流动)
    *   “家庭的总财富，是父亲的财富**加上**所有孩子财富的总和。” (信息从下向上传递)

通过在族谱树上应用这些规则，我们就能计算出每个人的完整信息和每个家庭的状况。

---
### **1. 属性文法 (Attribute Grammar)：形式化的定义**

**属性文法**，就是对上面思想的一个形式化定义。它是在**上下文无关文法 (CFG)** 的基础上，增加了两样东西：

1.  **属性 (Attributes)**:
    *   每个文法符号（终结符或非终结符）都可以关联一个或多个属性。
    *   **例子**:
        *   非终结符 `E` (表达式) 可能有一个属性 `E.val`，代表表达式的计算值。
        *   终结符 `id` (标识符) 可能有一个属性 `id.name`，代表标识符的字符串名字。
        *   非终结符 `T` (类型) 可能有一个属性 `T.type`，代表是 `int` 还是 `float`。

2.  **语义规则 (Semantic Rules)**:
    *   每一条**产生式**，都附带一组语义规则。
    *   这些规则定义了如何计算该产生式中，涉及的文法符号的属性值。
    *   规则只能使用产生式中**已有的**符号的属性值。

**例子**:
*   **产生式**: `E → E₁ + T`
*   **语义规则**: `{ E.val = E₁.val + T.val }`
    *   这条规则说：父节点 `E` 的 `val` 属性值，等于其子节点 `E₁` 和 `T` 的 `val` 属性值的和。

---
#### **1.1 两类属性：综合属性 vs. 继承属性**


**核心问题**: 在语法分析过程中，我们需要计算各种语义信息（比如一个表达式的值，一个变量的类型）。这些信息从哪里来，又流向哪里去？

**答案**: 信息在语法树上，只有两种基本的流动方向：**向上**或**向下/向旁**。这两种流动方向，就定义了两种根本不同的属性类型。

---
##### **1. 综合属性 (Synthesized Attributes) —— “汇总报告”**

*   **流动方向**: **自下而上 (Bottom-Up)**。信息从子节点流向父节点。
*   **定义**: 一个语法节点 `N` 的**综合属性**，其值是由 `N` 的**子节点**的属性值，或者 `N` 自身的一些内在属性（比如一个数字字面量的值）来计算的。
*   **直观理解**: 综合属性就像是在“**向上汇报工作**”或“**汇总结果**”。每个节点都在总结它的孩子们的信息，然后把总结报告交给自己的父节点。

*   **最经典的例子：表达式求值**
    *   **文法**: `E → E₁ + T`
    *   **语义规则**: `{ E.val = E₁.val + T.val }`
    *   **分析**:
        *   要计算 `E.val`，你**必须**先知道它的两个子节点 `E₁.val` 和 `T.val` 的值。
        *   信息流是 `E₁.val` → `E.val` 且 `T.val` → `E.val`。
        *   这是一种典型的**自下而上**的信息汇总。所以 `val` 是一个综合属性。

*   **另一个例子：语法树构建**
    *   **文法**: `E → E₁ + T`
    *   **语义规则**: `{ E.node_ptr = make_node('+', E₁.node_ptr, T.node_ptr) }`
    *   **分析**:
        *   要构建 `E` 对应的这个 `+` 节点，你**必须**先拥有它的左右子树的指针 `E₁.node_ptr` 和 `T.node_ptr`。
        *   信息（子树指针）也是**从下向上传递**来构建一棵更大的树。所以 `node_ptr` 也是一个综合属性。

**一句话总结综合属性**: **它的值由“下面”决定。**

---
##### **2. 继承属性 (Inherited Attributes) —— “指令下达”**

*   **流动方向**: **自上而下 (Top-Down)** 或 **从左到右 (Sideways)**。信息从父节点或兄弟节点流向子节点。
*   **定义**: 一个语法节点 `X` 的**继承属性**，其值是由 `X` 的**父节点**或 `X` 的**兄弟节点**的属性值来计算的。
*   **直观理解**: 继承属性就像是在“**向下传达指令**”或“**获取上下文信息**”。父节点把自己掌握的环境信息，传递给子节点，以便子节点能正确地完成自己的工作。

*   **最经典的例子：变量类型声明**
    *   **文法**: `D → T L` (D:声明, T:类型, L:变量列表)
    *   **语义规则**: `{ L.in_type = T.type }`
    *   **分析**:
        *   `L` (变量列表，比如 `x,y,z`) 本身并不知道自己是什么类型。这个“类型”信息必须从它的**兄弟节点** `T` (比如 `int`) 那里获得。
        *   信息流是 `T.type` → `L.in_type`。这是一个**从左到右**的“兄弟传信”。
    *   **再看 `L` 的展开**:
        *   **文法**: `L → id`
        *   **语义规则**: `{ add_symbol_type(id.name, L.in_type) }`
        *   **分析**:
            *   为了给符号表里的 `id` 登记正确的类型，`id` 节点需要知道这个类型是什么。
            *   这个类型信息 `L.in_type` 是从它的**父节点** `L` 那里“继承”来的。
            *   信息流是 `L.in_type` (父) → `L.in_type` (子，用于规则)。这是一个典型的**自上而下**的“指令下达”。
    *   所以，`in_type` 是一个继承属性。

**一句话总结继承属性**: **它的值由“上面”或“左边”决定。**

---
##### **3. 为什么需要区分这两种属性？**

**答案：因为它们与编译器的<u>不同工作流程</u>紧密相连。**

1.  **实现方式不同**:
    *   **综合属性**的计算流程，与**自下而上 (Bottom-Up) 语法分析**（如 LR 分析）的**规约 (Reduce)** 动作是**天作之合**。当分析器决定将 `β` 规约为 `A` 时，`β` 中所有符号的属性都已经计算完毕并存在栈里了，此时正是计算 `A` 的综合属性的最佳时机。
    *   **继承属性**的计算流程，与**自上而下 (Top-Down) 语法分析**（如 LL 分析）的**推导 (Expand)** 动作，或者**对语法树的深度优先遍历**是天作之合。当分析器要展开 `A` 时，可以把父节点的上下文信息（继承属性）传递下去。

2.  **文法分类的依据**:
    *   **S-属性文法** (只含综合属性) 和 **L-属性文法** (继承属性只能从左边兄弟获取) 这两种重要的分类，就是**根据属性的类型和流动方向**来定义的。
    *   这些分类决定了我们是否可以在**一次遍历**（或在语法分析的同时）就完成所有属性的计算。

---
##### **4. 语义规则**

#### 1. “出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则。”

这句话是在说：**“作为当前的管理者（产生式 `A → X Y`），你需要负责计算哪些数据？”**

*   **`出现在产生式右边的继承属性` (例如 `X.in`, `Y.in`)**:
    *   `X` 和 `Y` 是你的孩子。**继承属性**意味着“指令/上下文”。
    *   **谁给孩子下达指令？** 当然是你（父节点/当前产生式）。
    *   所以，你必须写规则来计算 `X.in` 和 `Y.in`（比如 `Y.in = X.out`）。

*   **`出现在产生式左边的综合属性` (例如 `A.val`)**:
    *   `A` 是你自己。**综合属性**意味着“汇报结果”。
    *   **谁负责汇总你的工作结果？** 当然还是你自己（当前产生式）。
    *   所以，你必须写规则来计算 `A.val`（比如 `A.val = X.val + Y.val`）。

**总结**：当前产生式负责计算：**“孩子的指令”** 和 **“自己的结果”**。

#### 2. “属性计算规则中只能使用本产生式的文法符号属性。”

这句话是在划定**作用域**。

*   你在写 `A → X Y` 的语义规则时，你只能引用 `A`, `X`, `Y` 这三个符号的属性。
*   你不能去引用产生式里没出现的符号（比如隔壁老王 `Z` 的属性），因为你根本不知道 `Z` 在哪里。

#### 3. “出现在产生式左边的继承属性和出现在产生式右边的综合属性不由本产生式的属性计算规则进行计算，由其它产生式的属性规则计算。”

这句话是在说：**“哪些数据是你等着别人算好给你的？”**

*   **`出现在产生式左边的继承属性` (例如 `A.in`)**:
    *   这是你（`A`）接收到的指令。
    *   **谁给你下指令？** 是**你的父亲**（也就是调用 `A` 的那个更高层的产生式，比如 `S → A`）。
    *   所以，`A.in` 不是在这里算的，而是**在上一层算的**。

*   **`出现在产生式右边的综合属性` (例如 `X.val`, `Y.val`)**:
    *   这是孩子们（`X`, `Y`）的工作成果。
    *   **谁计算孩子的成果？** 是**孩子自己**（也就是以 `X` 或 `Y` 为左部的产生式，比如 `X → ...`）。
    *   所以，`X.val` 不是在这里算的，而是**在下一层算的**。

---

### **图解总结**

对于产生式 `A → X Y`：

| 属性位置 | 属性类型 | 谁负责写计算规则？ | 例子 |
| :--- | :--- | :--- | :--- |
| **A (左边)** | **综合 (val)** | **本产生式** | `A.val = X.val + Y.val` (我汇总结果) |
| **A (左边)** | **继承 (in)** | **父产生式** | (我等着上级给我指令) |
| **X, Y (右边)** | **继承 (in)** | **本产生式** | `Y.in = X.val` (我给孩子下指令) |
| **X, Y (右边)** | **综合 (val)** | **子产生式** | (我等着孩子汇报结果) |

---


##### **5. 如何将继承属性改写为综合属性？**

S-属性文法（只含综合属性）是最容易在自下而上分析器中实现的。有时候，为了能使用这种简单的实现方式，我们会尝试把一些继承属性“改造”成综合属性。


*   **产生式左边**：`A` (父节点)
*   **产生式右边**：`X` 和 `Y` (子节点)



---

**为了适应 S-属性文法（只允许综合属性）的要求，通过修改文法结构，把原本需要“自上而下”传递的信息，变成“自下而上”传递。**

最经典的方法是：**重写文法，将“指令下达”模式改为“数据收集”模式。**

#### 场景：变量声明 `int a, b, c`

**1. 原始做法（使用继承属性）：**
*   **文法**:
    `D → T L`  (D:声明, T:类型, L:变量表)
    `L → id , L | id`
*   **逻辑**:
    1.  `T` 识别出 `int`。
    2.  `D` 把 `int` 作为**继承属性**传递给 `L`。
    3.  `L` 拿到 `int`，再传递给每一个 `id`，并把它们填入符号表。
*   **方向**: 类型信息 **向下** 流动。

**2. 改造做法（改为综合属性）：**
*   **思路**: 不要让 `L` 等着接收类型。让 `L` 先把所有的变量名 (`a`, `b`, `c`) 收集起来，打包成一个**列表**，然后作为**综合属性**向上返回给 `D`。最后在 `D` 这一层，拿到类型 `int` 和列表 `[a, b, c]`，再一次性处理。

*   **修改后的文法与规则**:
    *   `L → id`
        *   `{ L.list = make_list(id.name); }`  (创建一个只含id的列表，向上返回)
    *   `L → id , L₁`
        *   `{ L.list = append(L₁.list, id.name); }` (把id加入列表，向上返回)
    *   `D → T L`
        *   `{ for name in L.list: add_symbol(name, T.type); }`
        *   (在顶层，拿到 `T.type` 和 `L.list`，统一处理)

**改造的核心技巧**：
1.  **推迟行动**：原本在底层就要做的事（比如填符号表），推迟到顶层再做。
2.  **数据结构传递**：底层不再接收指令，而是构建数据结构（如列表、指针），把“我看到了什么”**汇报**上去。

通过这种方式，原本需要从 `T` 流向 `L` 的**继承属性**，就变为了 `L` 向上提供的**综合属性**，从而适配了只支持综合属性的分析器（如 YACC/Bison 对应的 LR 分析器）。

---

### **第二讲：基于属性文法的处理方法 —— 依赖图与文法分类**
上一讲，我们定义了属性文法的“蓝图”——**综合属性**（自下而上）和**继承属性**（自上而下）。现在，我们面临一个实际的工程问题：

> **对于一棵给定的语法树，我们应该按照什么样的<u>顺序</u>来计算树上各个节点的属性值？**

显然，我们不能随意计算。比如，在计算 `E.val = E₁.val + T.val` 时，必须先得到 `E₁.val` 和 `T.val` 的值。这就引出了“**依赖关系**”的概念。

#### **2.1 依赖图：可视化属性计算顺序**

*   **什么是依赖图 (Dependency Graph)？**
    *   对于一棵**特定的语法树**，我们可以画出一张图，来清晰地表示树中所有属性实例之间的依赖关系。
    *   **图的节点**: 语法树中**每个节点**的**每个属性**，都成为依赖图中的一个节点。
    *   **图的有向边**: 如果属性 `B` 的值依赖于属性 `A` 的值（即计算 `B` 的语义规则中用到了 `A`），那么就画一条从 `A` 到 `B` 的有向边 `A → B`。

*   **例子**: `E → E₁ + T { E.val = E₁.val + T.val }`
    *   依赖图会包含三条边：
        *   `E₁.val → E.val`
        *   `T.val → E.val`

*   **依赖图的作用**:
    *   **合法性检查**: 如果依赖图中存在**环路 (Cycle)**，那么这个属性文法就是**循环定义 (circularly defined)** 的，无法计算。例如 `{ A.x = B.y; B.y = A.x; }`。
    *   **确定计算顺序**: 依赖图是一个 **DAG (有向无环图)**。对这个图进行**拓扑排序 (Topological Sort)**，就能得到一个（或多个）合法的属性计算顺序。

**结论**: 依赖图是一个强大的理论工具，但为每一棵语法树都去构造和排序它，在实践中效率太低。我们需要更通用的、与特定语法树无关的计算策略。

---
#### **2.2 通用计算策略：树遍历**

既然属性是在树上传递的，那么最自然的计算方式就是**遍历语法树**。

*   **自下而上**的综合属性，天然地适合在**后序遍历 (Post-order Traversal)** 中计算。
*   **自上而下**的继承属性，天然地适合在**前序遍历 (Pre-order Traversal)** 或其他深度优先遍历中计算。

当两种属性混合时，情况就变得复杂，可能需要多次遍历或者更复杂的遍历策略。为了简化实现，并与我们学过的语法分析方法相结合，人们定义了两类**行为良好**的属性文法。

---
### **文法分类：S-属性文法 与 L-属性文法**

这两类文法，是对属性文法施加的**限制**，目的是让属性计算能够**更容易地**与特定的语法分析过程（自下而上或自上而下）相结合。

#### **2.3 S-属性文法 (S-Attributed Grammar)**

*   **S 的含义**: **Synthesized** (综合的)。
*   **定义**: 一个属性文法是 S-属性文法，如果它**只使用综合属性**。
*   **这是一个非常严格但简单的限制。**

*   **为什么需要它？—— 完美契合自下而上分析**
    *   我们回忆一下**自下而上 (Bottom-Up) 分析**（如 LR 分析）的过程：它先识别出子节点，然后将它们**规约 (Reduce)** 成父节点。
    *   这个“**先子后父**”的过程，与综合属性“**由子节点计算父节点**”的**自下而上**信息流，是**完全同构**的！
    *   **实现**: 我们可以在 LR 分析的**规约**动作发生时，立即执行相应的语义规则，计算出父节点的综合属性值。
    *   **例如**: 当分析器将 `E₁ + T` 规约为 `E` 时，`E₁.val` 和 `T.val` 的值（它们在分析栈的对应位置）已经是已知的了，此时可以立即计算 `E.val`。

*   **结论**: S-属性文法非常简单，可以**在 LR 分析过程中，一次性地、自下而上地**完成所有属性的计算。

#### **2.4 L-属性文法 (L-Attributed Grammar)**

*   **L 的含义**: **Left-to-right** (从左到右)。
*   **定义**: 这个定义更宽松，也更复杂。一个属性文法是 L-属性文法，如果对于它的**每一个**产生式 `A → X₁ X₂ ... Xₙ`，其附带的每一条语义规则（用于计算 `Xᵢ` 的某个**继承属性**），都**只依赖于**:
    1.  `A` 的**继承属性** (父传子)。
    2.  `Xᵢ` **左边**的兄弟节点 `X₁, ..., Xᵢ₋₁` 的**任意**属性 (左传右)。

*   **禁止的行为**: L-属性文法**禁止**一个属性依赖于它**右边**的兄弟节点的任何属性。

*   **直观理解**: L-属性文法允许的信息流是**严格从上到下、从左到右**的。

*   **为什么需要它？—— 契合自上而下和深度优先遍历**
    *   **自上而下 (Top-Down) 分析** (如 LL 分析) 的过程，本身就是一种从左到右的深度优先展开。
    *   当分析器处理到 `Xᵢ` 时，`A` 的继承属性（从上层传来）是已知的，`X₁` 到 `Xᵢ₋₁`（在 `Xᵢ` 左边）也已经被处理完毕，它们的属性值都是已知的。
    *   因此，`Xᵢ` 的继承属性所需要的所有信息，在处理到它的时候**恰好都已经准备好了**。
    *   **实现**: 可以在**深度优先遍历 (Depth-First Traversal)** 语法树的过程中，一次性地计算出所有属性。对于 LL 分析器，可以在推导过程中实时计算；对于 LR 分析器，则需要在生成语法树后，再进行一次从左到右的深度优先遍历来计算。

**重要关系**:
> **所有的 S-属性文法，也都是 L-属性文法。**
>
> (因为 S-属性文法根本没有继承属性，自然不会违反 L-属性文法的任何限制。)

---

