## <a name="toc"></a>词法分析器 - 知识点索引

*   [1. 文法转换状态图](#1-文法转换状态图)
  

*   [2. 有限自动机与左右线性文法转换](#2-有限自动机与线性文法)

## 1. 文法转换状态图 <a name="1-文法转换状态图"></a>
[返回目录](#toc)

**文法 G：**
*   `S→0S | 1S | 1A | 0B`
*   `A→1C | 1`
*   `B→0C | 0`
*   `C→0C | 1C | 0 | 1`

---

### 详细步骤：从右线性文法到 NFA

#### 第 1 步：确定状态集合

**规则**：
1.  文法中的**每一个非终结符** (`S`, `A`, `B`, `C`...），都对应自动机中的一个**状态**。
2.  为了处理形如 `P → a` 这样的“终止”规则，我们引入**一个全新的、唯一的、专门的接受状态**。我们通常叫它 `F` (Final State)。

**操作**：
*   根据文法中的非终结符 `S, A, B, C`，我们创建状态 `{S, A, B, C}`。
*   引入一个接受状态 `{F}`。
*   所以，我们自动机的**完整状态集合**是 `{S, A, B, C, F}`。

---

#### 第 2 步：确定开始状态

**规则**：
*   文法的**开始符号**，就是自动机的**开始状态**。

**操作**：
*   文法 G 的开始符号是 `S`。
*   所以，我们的自动机的**开始状态**就是 `S`。

---

#### 第 3 步：根据产生式画出转换弧

这是最核心的一步。我们需要遍历文法中的**每一条**产生式，然后把它翻译成图上的一条带标签的箭头。

**翻译规则有两种情况：**

**情况 A：产生式形如 `P → aQ`** (右边是一个终结符跟着一个非终结符)
*   **翻译**：画一条从状态 `P` 指向状态 `Q` 的箭头，箭头上标记终结符 `a`。
*   **含义**：当机器在状态 `P` 时，如果读到字符 `a`，它就转移到状态 `Q`。

**情况 B：产生式形如 `P → a`** (右边只有一个终结符)
*   **翻译**：画一条从状态 `P` 指向我们之前引入的**唯一接受状态 `F`** 的箭头，箭头上标记终结符 `a`。
*   **含义**：当机器在状态 `P` 时，如果读到字符 `a`，它就完成了识别任务，转移到最终的接受状态。

**操作 (逐条翻译文法 G)**：

1.  `S→0S`  (情况A) =>  画一条从 `S` 指向 `S` 的弧，标记为 `0`。
2.  `S→1S`  (情况A) =>  画一条从 `S` 指向 `S` 的弧，标记为 `1`。
3.  `S→1A`  (情况A) =>  画一条从 `S` 指向 `A` 的弧，标记为 `1`。
4.  `S→0B`  (情况A) =>  画一条从 `S` 指向 `B` 的弧，标记为 `0`。
5.  `A→1C`  (情况A) =>  画一条从 `A` 指向 `C` 的弧，标记为 `1`。
6.  **`A→1`   (情况B)** =>  画一条从 `A` 指向 **接受状态 `F`** 的弧，标记为 `1`。
7.  `B→0C`  (情况A) =>  画一条从 `B` 指向 `C` 的弧，标记为 `0`。
8.  **`B→0`   (情况B)** =>  画一条从 `B` 指向 **接受状态 `F`** 的弧，标记为 `0`。
9.  `C→0C`  (情况A) =>  画一条从 `C` 指向 `C` 的弧，标记为 `0`。
10. `C→1C`  (情况A) =>  画一条从 `C` 指向 `C` 的弧，标记为 `1`。
11. **`C→0`   (情况B)** =>  画一条从 `C` 指向 **接受状态 `F`** 的弧，标记为 `0`。
12. **`C→1`   (情况B)** =>  画一条从 `C` 指向 **接受状态 `F`** 的弧，标记为 `1`。

---

#### 第 4 步：确定接受状态

**规则**：
*   我们通过引入一个**唯一的、全新的状态 `F`** 来处理所有的终止规则。因此，这个 `F` 就是我们构造的 NFA 的**唯一接受状态**。

**操作**：
*   在画图时，把状态 `F` 画成**双圈圈**。

---

### 最终结果

把上面所有步骤画出来，你就得到了一个完整的、与右线性文法 G 等价的 NFA。

*   **状态集**: `{S, A, B, C, F}`
*   **开始状态**: `S`
*   **接受状态**: `{F}`
*   **转换弧**: 由上述12条产生式一一对应生成。

这个 NFA 就是我们上一回答中画出的第一张图。这个方法非常机械化，只要你遵循这四步，就不会出错。

**回答你的核心问题**：
> 满足什么条件的状态算作接受态？

**答案**：在我们这种系统性的构造方法中，我们**主动创造**了一个唯一的接受状态 `F`。任何一个能让文法推导结束的规则 (`P -> a`)，在图中都表现为一条指向这个 `F` 状态的路径。所以，**只有 `F` 是接受状态**。文法中的其他非终结符 `S, A, B, C` 对应的都不是接受状态。

## 2. 有限自动机与左右线性文法转换 <a name="2-有限自动机与线性文法"></a>
[返回目录](#toc)


### 1. 故事的起点：语言的反转

让我们先忘掉文法和自动机，只看最纯粹的字符串。

*   **字符串的反转**:
    *   如果有一个字符串 `w = "abc"`，那么它的**反转** `wᴿ` 就是 `"cba"`。

*   **语言的反转**:
    *   一个语言 `L` 是一个字符串的集合。
    *   那么 `L` 的**反转语言** `Lᴿ`，就是 `L` 中**每一个字符串都进行反转**后，所形成的新集合。
    *   **例子**:
        *   `L = {"a", "ab", "abb"}`
        *   `Lᴿ = {"a", "ba", "bba"}`

---

### 2. 核心洞察：文法与反转

现在，我们把文法引入这个故事。

*   **右线性文法 (RLG) 的生成过程**:
    *   它的规则是 `A → aB`。
    *   它的推导过程是：`S ⇒ aP ⇒ abQ ⇒ abcR ...`
    *   观察这个过程，你会发现它是**从左到右**，一个一个地“吐出”终结符，来生成字符串的。

*   **左线性文法 (LLG) 的生成过程**:
    *   它的规则是 `A → Ba`。
    *   它的推导过程是：`S ⇒ Pabc ⇒ Qbc ⇒ Rc ⇒ c ...`
    *   这个过程看起来很奇怪，它先把非终结符推到最左边，然后从右到左，一个一个地把终结符“固定”下来。

**关键的顿悟来了：**

> 如果一个**右线性文法 G** 能生成语言 `L`，那么我们似乎可以设计一个**左线性文法 G'**，让它的生成过程，正好**镜像**了 G 的生成过程，从而生成 `L` 的反转语言 `Lᴿ`。

反之亦然，如果 G 能生成 `L`，那么 G 的“镜像” G' 就能生成 `Lᴿ`。那么 G' 的“镜像”的“镜像”（也就是G自己），就能生成 `Lᴿ` 的反转，也就是 `L`。

**这个“镜像”操作，就是把产生式 `A → aB` 变成 `A → Ba`。**

---

### 3. 中间人：自动机——让“反转”变得可见

直接在文法层面思考“镜像”和“反转”非常抽象。而**有限自动机**，给了我们一个**看得见、摸得着**的几何模型，让“反转”这个操作变得异常简单直观。

*   **自动机识别字符串的过程**:
    *   `S --a--> P --b--> Q --c--> R`
    *   这是一个从左到右，一个字符一个字符地“吃掉”输入字符串的过程。它和**右线性文法的生成过程**是完全同构的！

*   **如何让自动机识别一个反转的字符串 `cba`？**
    *   很简单，我们把上面那台机器的**所有箭头都反过来**！
    *   `S <--a-- P <--b-- Q <--c-- R`
    *   现在，这台新机器就可以从 `R` 状态开始，吃一个 `c` 到 `Q`，吃一个 `b` 到 `P`，吃一个 `a` 到 `S`。

**这就是第二步“反转操作”的根本原因！**

**自动机的反转操作，在物理上（几何上）实现了语言的反转。**

1.  我们有一个右线性文法 `G`，它生成语言 `L`。
2.  我们把它变成 NFA，我们叫它 `N`。`N` 识别的语言也是 `L`。
3.  我们把 `N` 的**所有箭头、开始/结束状态都反转**，得到一个新的 NFA，我们叫它 `Nᴿ`。
4.  根据上面的理论，`Nᴿ` 识别的语言，就是 `L` 的反转语言 `Lᴿ`。
5.  现在，我们再把 `Nᴿ` 这个自动机，翻译回文法。因为 `Nᴿ` 是一个“从右到左”工作的机器，所以它自然而然地就对应了一个**左线性文法**，我们叫它 `G'`。
6.  那么，这个左线性文法 `G'` 生成的语言是什么？就是 `Lᴿ`！

**但是我们的目标是生成 `L`，不是 `Lᴿ` 啊？**

这里有一个非常巧妙的对称性：
> 能被右线性文法描述的语言（正则语言），它的反转语言也一定能被右线性文法描述。反之，能被左线性文法描述的语言，它的反转也一定能被左线性文法描述。而且，一个语言能被右线性文法描述，**当且仅当**它能被左线性文法描述。

这意味着：
*   我们用 RLG `G` 生成 `L`。
*   我们把它变成 NFA `N` (识别 `L`)。
*   我们反转 NFA `N` 得到 `Nᴿ` (识别 `Lᴿ`)。
*   我们把 `Nᴿ` 翻译成 LLG `G'` (生成 `Lᴿ`)。
*   **如果我们把 `G'` 的产生式 `A → Ba` 再反转成 `A → aB`，就会得到一个 RLG，它能生成 `(Lᴿ)ᴿ = L`！**

**但是题目要求的是一个能生成 `L` 的左线性文法！**

这里我之前的解释有一个小小的跳跃。让我们重新审视这个过程。

**正确的逻辑链条应该是这样的：**
1.  **RLG (G) 生成 L。**
2.  **RLG (G) 对应 NFA (N)，N 识别 L。**
3.  **反转 N 得到 Nᴿ，Nᴿ 识别 Lᴿ。**
4.  **将 Nᴿ 翻译成 RLG，我们叫 G_rev_R，它生成 Lᴿ。**
5.  **将 G_rev_R 的产生式 `A -> aB` 全部镜像成 `A -> Ba`，得到 LLG，我们叫 G_rev_L。这个 G_rev_L 会生成 (Lᴿ)ᴿ = L！**

这个过程太复杂了！所以人们发现了一个捷径。

---
### 捷径：重新定义“自动机到文法的翻译”

我们可以重新定义自动机和文法之间的关系，来跳过语言反转的思考。

*   **标准看法**：
    *   `A -> aB`  <=>  `A --a--> B`
    *   这是 RLG 和 NFA 的关系。

*   **另一种看法**：
    *   `A -> Ba`  <=>  `B --a--> A`
    *   这也是 LLG 和 NFA 的关系！一个左线性规则，可以看作是从**箭头指向**的那个状态，生成一个字符，然后**回到**箭头发出的那个状态。

**现在，我们再看“反转操作”的意义：**

1.  我们有 RLG `G` 和 NFA `N`，它们都对应 `L`。它们之间的关系是 `A -> aB` <=> `A --a--> B`。
2.  我们想找到一个 LLG `G'`，它也对应 `L`。
3.  `G'` 里的规则是 `P -> Q c`。根据“另一种看法”，这对应 NFA 里的转换 `Q --c--> P`。
4.  所以，`G'` 中 `P -> Q c` 这条规则，正好对应 `G` 中 `Q -> c P` 这条规则在 NFA 里的转换 `Q --c--> P`。

这还是太绕了。

**让我们回到最直观、最正确的理解上，也就是我第一个回答里的三步法。那个方法是正确的，它的逻辑是：**

> 一个**自动机 `N`** 和一个**左线性文法 `G'`** 之间可以建立一种**新的对应关系**：
> *   `N` 中的转换 `P --a--> Q` 直接对应 `G'` 中的产生式 `Q → Pa`。
> *   `N` 中的开始状态 `S_N` 对应 `G'` 中能推出 `ε` 的非终结符。
> *   `N` 中的接受状态 `F_N` 对应 `G'` 中的开始符号。

**为什么这种对应关系是正确的？**
*   我们看 `G'` 的推导：`F_N ⇒ P₁a₁ ⇒ P₂a₂a₁ ⇒ ... ⇒ S_N a_n...a₁ ⇒ a_n...a₁`。
*   它从 `F_N` 开始，从右到左生成了 `a_n...a₁`。
*   我们再看 `N` 的识别过程：`S_N --a_n--> ... --> P₂ --a₂--> P₁ --a₁--> F_N`。
*   它从 `S_N` 开始，从左到右识别了 `a_n...a₁`。

**这两个过程完美地互为逆过程！**

**结论**：
第二步的“反转操作”不是一个随意的、凑巧有效的技巧。它的本质是利用了**语言反转**这个深刻的理论。
我们通过**物理上反转自动机**，来模拟**数学上反转语言**的过程。然后再利用自动机和不同类型文法之间灵活的对应关系，最终得到我们想要的文法。

这个三步法，本质上是把一个复杂的、纯代数的文法转换问题，变成了一个**直观的、几何的图形操作问题**。这正是自动机理论的魅力所在。
