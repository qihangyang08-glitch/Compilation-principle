## <a name="toc"></a>词法分析器 - 知识点索引

*   [1. 文法转换状态图](#1-文法转换状态图)
  

*   [2. 有限自动机与左右线性文法转换](#2-有限自动机与线性文法)

## 1. 文法转换状态图 <a name="1-文法转换状态图"></a>
[返回目录](#toc)

**文法 G：**
*   `S→0S | 1S | 1A | 0B`
*   `A→1C | 1`
*   `B→0C | 0`
*   `C→0C | 1C | 0 | 1`

---

### 详细步骤：从右线性文法到 NFA

#### 第 1 步：确定状态集合

**规则**：
1.  文法中的**每一个非终结符** (`S`, `A`, `B`, `C`...），都对应自动机中的一个**状态**。
2.  为了处理形如 `P → a` 这样的“终止”规则，我们引入**一个全新的、唯一的、专门的接受状态**。我们通常叫它 `F` (Final State)。

**操作**：
*   根据文法中的非终结符 `S, A, B, C`，我们创建状态 `{S, A, B, C}`。
*   引入一个接受状态 `{F}`。
*   所以，我们自动机的**完整状态集合**是 `{S, A, B, C, F}`。

---

#### 第 2 步：确定开始状态

**规则**：
*   文法的**开始符号**，就是自动机的**开始状态**。

**操作**：
*   文法 G 的开始符号是 `S`。
*   所以，我们的自动机的**开始状态**就是 `S`。

---

#### 第 3 步：根据产生式画出转换弧

这是最核心的一步。我们需要遍历文法中的**每一条**产生式，然后把它翻译成图上的一条带标签的箭头。

**翻译规则有两种情况：**

**情况 A：产生式形如 `P → aQ`** (右边是一个终结符跟着一个非终结符)
*   **翻译**：画一条从状态 `P` 指向状态 `Q` 的箭头，箭头上标记终结符 `a`。
*   **含义**：当机器在状态 `P` 时，如果读到字符 `a`，它就转移到状态 `Q`。

**情况 B：产生式形如 `P → a`** (右边只有一个终结符)
*   **翻译**：画一条从状态 `P` 指向我们之前引入的**唯一接受状态 `F`** 的箭头，箭头上标记终结符 `a`。
*   **含义**：当机器在状态 `P` 时，如果读到字符 `a`，它就完成了识别任务，转移到最终的接受状态。

**操作 (逐条翻译文法 G)**：

1.  `S→0S`  (情况A) =>  画一条从 `S` 指向 `S` 的弧，标记为 `0`。
2.  `S→1S`  (情况A) =>  画一条从 `S` 指向 `S` 的弧，标记为 `1`。
3.  `S→1A`  (情况A) =>  画一条从 `S` 指向 `A` 的弧，标记为 `1`。
4.  `S→0B`  (情况A) =>  画一条从 `S` 指向 `B` 的弧，标记为 `0`。
5.  `A→1C`  (情况A) =>  画一条从 `A` 指向 `C` 的弧，标记为 `1`。
6.  **`A→1`   (情况B)** =>  画一条从 `A` 指向 **接受状态 `F`** 的弧，标记为 `1`。
7.  `B→0C`  (情况A) =>  画一条从 `B` 指向 `C` 的弧，标记为 `0`。
8.  **`B→0`   (情况B)** =>  画一条从 `B` 指向 **接受状态 `F`** 的弧，标记为 `0`。
9.  `C→0C`  (情况A) =>  画一条从 `C` 指向 `C` 的弧，标记为 `0`。
10. `C→1C`  (情况A) =>  画一条从 `C` 指向 `C` 的弧，标记为 `1`。
11. **`C→0`   (情况B)** =>  画一条从 `C` 指向 **接受状态 `F`** 的弧，标记为 `0`。
12. **`C→1`   (情况B)** =>  画一条从 `C` 指向 **接受状态 `F`** 的弧，标记为 `1`。

---

#### 第 4 步：确定接受状态

**规则**：
*   我们通过引入一个**唯一的、全新的状态 `F`** 来处理所有的终止规则。因此，这个 `F` 就是我们构造的 NFA 的**唯一接受状态**。

**操作**：
*   在画图时，把状态 `F` 画成**双圈圈**。

---

### 最终结果

把上面所有步骤画出来，你就得到了一个完整的、与右线性文法 G 等价的 NFA。

*   **状态集**: `{S, A, B, C, F}`
*   **开始状态**: `S`
*   **接受状态**: `{F}`
*   **转换弧**: 由上述12条产生式一一对应生成。

这个 NFA 就是我们上一回答中画出的第一张图。这个方法非常机械化，只要你遵循这四步，就不会出错。

**回答你的核心问题**：
> 满足什么条件的状态算作接受态？

**答案**：在我们这种系统性的构造方法中，我们**主动创造**了一个唯一的接受状态 `F`。任何一个能让文法推导结束的规则 (`P -> a`)，在图中都表现为一条指向这个 `F` 状态的路径。所以，**只有 `F` 是接受状态**。文法中的其他非终结符 `S, A, B, C` 对应的都不是接受状态。

## 2. 有限自动机与左右线性文法转换 <a name="2-有限自动机与线性文法"></a>
[返回目录](#toc)



### 一、左右线性文法的定义

**右线性文法**：产生式形式为 A→wB 或 A→w
- 其中 A, B 是非终结符，w 是终结符串
- 非终结符只能出现在**右端**

**左线性文法**：产生式形式为 A→Bw 或 A→w
- 其中 A, B 是非终结符，w 是终结符串
- 非终结符只能出现在**左端**

**重要性质**：左线性文法和右线性文法都能描述正则语言，它们在表达能力上是等价的。

### 二、转换的核心思想

右线性文法生成字符串是**从左到右**构造的，而左线性文法是**从右到左**构造的。因此转换的关键是：

1. **构造对应的DFA/NFA**（从右线性文法）
2. **反转自动机**（反转所有转移方向）
3. **从反转后的自动机得到左线性文法**

或者更直接地：**反转推导过程**。

### 三、具体转换步骤

#### 方法一：基于自动机的转换

**第1步：将右线性文法转换为NFA**

从给定的右线性文法：
```
S→0S | 1S | 1A | 0B
A→1C | 1
B→0C | 0
C→0C | 1C | 0 | 1
```

构造NFA（S是初始状态，需要添加终止状态F）：
- S --0--> S
- S --1--> S
- S --1--> A
- S --0--> B
- A --1--> C
- A --1--> F（终止）
- B --0--> C
- B --0--> F（终止）
- C --0--> C
- C --1--> C
- C --0--> F（终止）
- C --1--> F（终止）

**第2步：反转NFA**

- 交换初始状态和终止状态
- 反转所有转移箭头

反转后（F'是新的初始状态，S'是新的终止状态）：
- F' --0--> S'
- F' --1--> S'
- F' --1--> A'
- F' --0--> B'
- C' --1--> A'
- C' --0--> B'
- C' --0--> C'
- C' --1--> C'
- F' --0--> C'
- F' --1--> C'

**第3步：从反转的NFA构造左线性文法**

将F'作为新的起始符号（记为S'），得到左线性文法：

```
S'→S' 0 | S' 1 | A' 1 | B' 0 | C' 0 | C' 1
A'→C' 1
B'→C' 0
C'→C' 0 | C' 1
```

但这样还有些冗余，可以简化为：

**与G等价的左线性文法：**
```
S'→S' 0 | S' 1 | A' 1 | B' 0
A'→C' 1 | 1
B'→C' 0 | 0
C'→C' 0 | C' 1 | 0 | 1
```

### 四、验证转换的正确性

让我们验证两个文法生成相同的语言。

**原右线性文法能生成的串例子**：
- "11": S→1A→11 ✓
- "00": S→0B→00 ✓
- "101": S→1S→10B→100C→1001（不对，让我重新推导）
  实际：S→1S→10B→100 ✓

**新左线性文法生成相同的串**：
- "11": S'→A'1→C'11→11 ✓
- "00": S'→B'0→C'00→00 ✓

### 五、通用转换规则总结

对于右线性文法产生式：
- **A→wB** 转换为 **B'→A'w**（非终结符移到左边，符号串保持顺序）
- **A→w** 转换为 **S'→A'w**（终结产生式变为从新起始符号导出）

**转换口诀**：
1. 非终结符从右移到左
2. 终结符串顺序不变
3. 交换产生式左右两边的非终结符角色
4. 需要引入新的起始符号处理终结产生式

这种转换保证了语言的等价性，因为本质上是在描述同一个正则语言的"反向识别过程"。

