
### 第一部分：怎么证明一个文法是二义性的？（找茬法）

**核心定义**：
如果文法中的**某一个句子**，能画出**两棵不同的语法树**（或者能写出**两个不同的最左推导**），那这个文法就是二义性的。

**做题“找茬”套路：**

1.  **锁定目标**：
    在文法中寻找形如 **`A → A op A`** （比如 `E → E + E`）或者 **`S → if C S | if C S else S`** 这种结构的产生式。这些是二义性的“万恶之源”。

2.  **构造“特定”句子**：
    不要找太简单的，要找一个刚好能触发两种结合方式的句子。
    *   **算术题**：找“两步运算”。例如对于 `E → E+E | E*E | id`，构造 **`id + id * id`**。
    *   **If-Else题**：找“嵌套”。构造 **`if c then if c then s else s`**。

3.  **画树证明（必杀技）**：
    你需要展示两棵树，一棵树代表“先算左边/外层”，另一棵代表“先算右边/内层”。

    *   **例子**：文法 `E → E - E | id`，句子 `id - id - id`。
    *   **树 1 (左结合，(a-b)-c)**：
        *   根节点 `E` 分裂为 `E - E`。
        *   **左边**的 `E` 继续分裂为 `E - E`。
        *   结果：树是“向左歪”的。
    *   **树 2 (右结合，a-(b-c))**：
        *   根节点 `E` 分裂为 `E - E`。
        *   **右边**的 `E` 继续分裂为 `E - E`。
        *   结果：树是“向右歪”的。

    **答题模板**：
    > “对于句子 `.......`，可以构造出以下两棵不同的语法树（画图），因此该文法是二义性的。”

---

### 第二部分：怎么把文法改为无二义性？（分层法）

这是难点，但有标准公式。消除二义性的本质是：**在文法中强制规定“优先级”和“结合性”。**

我们以最经典的算术表达式为例：`E → E+E | E*E | (E) | id`

#### 技巧 1：由低到高“分层” (解决优先级)

优先级越**低**的运算符，在语法树中越**靠近根部**（越后计算）；优先级越**高**的，越**靠近叶子**（越先计算）。

我们需要为每一个优先级引入一个新的**非终结符**。

*   **第一层 (最低级，加法)**：用开始符号 `E` (Expression) 表示。
*   **第二层 (中级，乘法)**：引入新符号 `T` (Term) 表示。
*   **第三层 (最高级，括号/数字)**：引入新符号 `F` (Factor) 表示。

**层级关系**：`E` 由 `T` 组成，`T` 由 `F` 组成。

#### 技巧 2：递归方向定“结合性” (解决结合性)

*   **左结合**（如 `+`, `-`, `*`, `/`）：使用**左递归** (`E → E + T`)。
*   **右结合**（如幂运算 `^`，赋值 `=`）：使用**右递归** (`E → T + E`)。

#### **实战操作步骤（背下来这个模板）：**

假设我们要改写含 `+` (低，左结合) 和 `*` (高，左结合) 的文法。

**Step 1: 写最低优先级的规则 (E)**
因为是左结合，所以 `E` 出现在左边，右边由高一级的 `T` 填充。
*   `E → E + T | T`

**Step 2: 写下一级优先级的规则 (T)**
因为 `*` 也是左结合，所以 `T` 出现在左边，右边由更高一级的 `F` 填充。
*   `T → T * F | F`

**Step 3: 写最高优先级的规则 (F)**
基本单元和括号（括号能强行提升优先级，回到最顶层 `E`）。
*   `F → (E) | id`

**最终结果：**
1. `E → E + T | T`
2. `T → T * F | F`
3. `F → (E) | id`

---

#### **进阶：如果有右结合怎么办？**

假设增加一个幂运算 `^` (优先级最高，**右结合**)。
我们要再加一层，插在 `T` 和 `F` 之间，哪怕叫 `G`。

1.  `E → E + T | T`  (加法)
2.  `T → T * G | G`  (乘法)
3.  **`G → F ^ G | F`**  (**注意！右结合用右递归，G在右边**)
4.  `F → (E) | id`

---

### 总结一张表

| 目的 | 做法 | 产生式口诀 |
| :--- | :--- | :--- |
| **证明二义性** | 找一个句子，画两棵树 | 找 `A -> A op A`，构造 `id op id op id` |
| **消除二义性** | **分层** + **定方向** | **低级引用高级** |
| **规定左结合** | 左递归 | `A -> A op B | B` (A在左) |
| **规定右结合** | 右递归 | `A -> B op A | B` (A在右) |
| **规定优先级** | 层级隔离 | 加法层找乘法，乘法层找原子 |

掌握了这个“分层”和“递归方向”的逻辑，90% 的消除二义性题目（除了悬垂 else 那种特殊的）都能迎刃而解。
