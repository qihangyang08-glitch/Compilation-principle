
### 第一部分：怎么证明一个文法是二义性的？（找茬法）

**核心定义**：
如果文法中的**某一个句子**，能画出**两棵不同的语法树**（或者能写出**两个不同的最左推导**），那这个文法就是二义性的。

**做题“找茬”套路：**

1.  **锁定目标**：
    在文法中寻找形如 **`A → A op A`** （比如 `E → E + E`）或者 **`S → if C S | if C S else S`** 这种结构的产生式。这些是二义性的“万恶之源”。

2.  **构造“特定”句子**：
    不要找太简单的，要找一个刚好能触发两种结合方式的句子。
    *   **算术题**：找“两步运算”。例如对于 `E → E+E | E*E | id`，构造 **`id + id * id`**。
    *   **If-Else题**：找“嵌套”。构造 **`if c then if c then s else s`**。

3.  **画树证明（必杀技）**：
    你需要展示两棵树，一棵树代表“先算左边/外层”，另一棵代表“先算右边/内层”。

    *   **例子**：文法 `E → E - E | id`，句子 `id - id - id`。
    *   **树 1 (左结合，(a-b)-c)**：
        *   根节点 `E` 分裂为 `E - E`。
        *   **左边**的 `E` 继续分裂为 `E - E`。
        *   结果：树是“向左歪”的。
    *   **树 2 (右结合，a-(b-c))**：
        *   根节点 `E` 分裂为 `E - E`。
        *   **右边**的 `E` 继续分裂为 `E - E`。
        *   结果：树是“向右歪”的。

    **答题模板**：
    > “对于句子 `.......`，可以构造出以下两棵不同的语法树（画图），因此该文法是二义性的。”

---

# 📝 消除文法二义性（分层法）

## 1. 核心心法

消除二义性的本质，就是**把人类语言中的“潜规则”（优先级和结合性），翻译成文法的“层级结构”。**

*   **优先级 (Precedence)** $\rightarrow$ **由外向内分层**
    *   **越低**优先级的运算，写在文法**越外层**（离开始符号越近）。
    *   **越高**优先级的运算，写在文法**越内层**（离叶子节点越近）。
    *   **口诀**：*剥洋葱法——先剥皮（低），再吃心（高）。*

*   **结合性 (Associativity)** $\rightarrow$ **递归方向**
    *   **左**结合（从左往右算，如 `+`, `*`） $\rightarrow$ 使用 **左**递归 (`A -> A op B`).
    *   **右**结合（从右往左算，如 `^`, `=`） $\rightarrow$ 使用 **右**递归 (`A -> B op A`).

---

## 2. 通用解题模板（三步走）

假设题目给你一个大锅乱炖的二义性文法：`S -> S op1 S | S op2 S | ... | atom`。

### **Step 1: 排座次（定优先级）**
自己决定（或根据数学常识）谁高谁低。
*   Level 1 (最低): 运算符 `op_low`
*   Level 2 (中等): 运算符 `op_mid`
*   Level 3 (最高): 原子 `atom` / 括号 `(S)`

### **Step 2: 封官职（引入非终结符）**
为每一层级分配一个专属符号。
*   Level 1 $\rightarrow$ `E` (Expression, 开始符号)
*   Level 2 $\rightarrow$ `T` (Term)
*   Level 3 $\rightarrow$ `F` (Factor)

### **Step 3: 写规则（套公式）**
从最低层写起。每一层的公式是：
> **本层符号 $\rightarrow$ 本层符号 `op` 下层符号 | 下层符号**

*   如果是**左**结合：`E -> E op T | T`
*   如果是**右**结合：`E -> T op E | T`

---

## 3. 实战案例详解

### 案例一：经典四则运算（全左结合）
**目标**：处理 `+` (低), `*` (高), `id` (原子), `()` (最高)。全是左结合。

*   **第 1 层（处理 +）**：
    *   符号：`E`
    *   下级：`T`
    *   规则：**`E -> E + T | T`**
    *   *解析：左递归保证了 `a+b+c` 是 `(a+b)+c`。*

*   **第 2 层（处理 *）**：
    *   符号：`T`
    *   下级：`F`
    *   规则：**`T -> T * F | F`**
    *   *解析：被包裹在 E 层之下，保证了先乘后加。*

*   **第 3 层（处理原子）**：
    *   符号：`F`
    *   规则：**`F -> (E) | id`**
    *   *解析：`()` 是“虫洞”，强行跳回最顶层 `E`，实现最高优先级。*

---

### 案例二：混合结合性（含右结合）
**目标**：处理 `&` (低，左结合), `#` (高，**右结合**), `id`。
*比如：`a # b # c` 应该算作 `a # (b # c)`*

*   **第 1 层（处理 &，低，左结合）**：
    *   符号：`S`
    *   下级：`T`
    *   规则：**`S -> S & T | T`**  (左递归)

*   **第 2 层（处理 #，高，右结合）**：
    *   符号：`T`
    *   下级：`F`
    *   规则：**`T -> F # T | F`**
    *   *注意：这里用了右递归！`T` 出现在运算符 `#` 的右边。*

*   **第 3 层（原子）**：
    *   符号：`F`
    *   规则：**`F -> id`**

---

### 案例三：特殊情况 —— 悬垂 Else
**二义性来源**：`S -> if C S | if C S else S`
**解决思路**：不是分层，而是**分类**。强制规定 `then` 和 `else` 之间必须是“完整”的语句。

*   **M (Matched)**: 完整的、配对的语句（要么不是if，要么有else）。
*   **U (Unmatched)**: 残缺的、没配对的语句（单独的if，或者else里面包含残缺if）。

**无二义性文法**：
1.  `S -> M | U`  (总入口)
2.  `M -> if C then M else M | other`  (要么完整嵌套，要么是非if语句)
3.  `U -> if C then S | if C then M else U` (以此强制 else 只能匹配最近的 if)

---

## 4. 极速检查表 (Cheat Sheet)

做完题后，扫一眼这个表自查：

1.  **分层了吗？** 是否每一类优先级的运算符都有独立的非终结符？
2.  **方向对吗？**
    *   左结合 $\rightarrow$ `A -> A op B` ?
    *   右结合 $\rightarrow$ `A -> B op A` ?
3.  **兜底了吗？** 每一层的规则最后是否有 `| 下一层`？（例如 `E -> E+T | T` 中的 `| T` 绝对不能漏）。
4.  **闭环了吗？** 最底层 `F` 是否包含了 `(E)` 这种能跳回顶层的结构？
